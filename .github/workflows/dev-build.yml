name: Development Build

# This workflow handles development builds with intelligent build skipping:
# - Feature branches: Build artifacts, no releases (testing only)  
# - Develop branch: Build artifacts + create development releases (when meaningful changes are merged)
# - Main/Master branch: ALWAYS build + create production releases (releases require fresh artifacts)
#
# Smart merge detection prevents redundant builds by:
# - Main/Master: Always builds (never skip releases!)
# - Detecting merge commits vs regular commits
# - For merges: Analyzing actual changes being merged (not just the merge commit)
# - For regular commits: Comparing against previous commit
# - Skipping builds when only documentation/config files changed (.md, .txt, .yml, .yaml, .github/)
# - Respecting [skip ci] or [ci skip] in commit messages (except on main/master)
#
# This ensures develop/main branches BUILD when feature branches are merged (as they should!)
# while still preventing redundant builds when no meaningful code changes exist.

on:
  push:
    branches: 
      - develop
      - dev
      - main
      - master
      - 'feature/**'
      - 'feat/**'
      - 'fix/**'
  workflow_dispatch:  # Allow manual triggering

env:
  QT_VERSION: '6.8.3'

jobs:
  setup-version:
    name: Setup Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      numeric_version: ${{ steps.version.outputs.numeric_version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      should_build: ${{ steps.check-changes.outputs.should_build }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for proper versioning
      
      - name: Check for meaningful changes
        id: check-changes
        run: |
          # Always build on main/master branch (releases)
          if [[ "${{ github.ref_name }}" == "main" || "${{ github.ref_name }}" == "master" ]]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Always building on main/master branch for release"
            exit 0
          fi
          
          # Skip builds if commit message contains [skip ci] or [ci skip]
          if echo "${{ github.event.head_commit.message }}" | grep -E "\[(skip ci|ci skip)\]" > /dev/null; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "Build skipped due to [skip ci] in commit message"
            exit 0
          fi
          
          # Check if this is a merge commit (has multiple parents)
          PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
          PARENT_COUNT=$((PARENT_COUNT - 1))  # Subtract 1 because first item is the commit hash itself
          
          if [ "$PARENT_COUNT" -gt 1 ]; then
            echo "Detected merge commit with $PARENT_COUNT parents"
            
            # For merge commits, check the actual changes being merged
            # Compare against the first parent (the target branch before merge)
            FIRST_PARENT=$(git rev-parse HEAD^1)
            echo "Comparing changes against first parent: $FIRST_PARENT"
            
            # Get all changed files in this merge, excluding documentation/config files but allowing workflow changes
            CHANGED_FILES=$(git diff --name-only $FIRST_PARENT HEAD | grep -v -E "(\.md$|test.*\.txt$|README.*\.txt$|CHANGELOG.*\.txt$)" | grep -v -E "(\.yml$|\.yaml$)" | wc -l)
            WORKFLOW_FILES=$(git diff --name-only $FIRST_PARENT HEAD | grep -E "^\.github/workflows/.*\.(yml|yaml)$" | wc -l)
            TOTAL_MEANINGFUL=$((CHANGED_FILES + WORKFLOW_FILES))
            echo "Meaningful files changed in merge: $CHANGED_FILES"
            echo "Workflow files changed: $WORKFLOW_FILES"
            echo "Total meaningful changes: $TOTAL_MEANINGFUL"
            
            if [ "$TOTAL_MEANINGFUL" -eq 0 ]; then
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "Skipping build - merge contains no meaningful code changes"
              exit 0
            else
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "Build will proceed - merge contains $TOTAL_MEANINGFUL meaningful changes (code: $CHANGED_FILES, workflows: $WORKFLOW_FILES)"
              exit 0
            fi
          else
            echo "Regular commit (not a merge) - checking for meaningful changes"
            
            # For regular commits, check against previous commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep -v -E "(\.md$|test.*\.txt$|README.*\.txt$|CHANGELOG.*\.txt$)" | grep -v -E "(\.yml$|\.yaml$)" | wc -l)
            WORKFLOW_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E "^\.github/workflows/.*\.(yml|yaml)$" | wc -l)
            TOTAL_MEANINGFUL=$((CHANGED_FILES + WORKFLOW_FILES))
            echo "Meaningful files changed: $CHANGED_FILES"
            echo "Workflow files changed: $WORKFLOW_FILES" 
            echo "Total meaningful changes: $TOTAL_MEANINGFUL"
            
            if [ "$TOTAL_MEANINGFUL" -eq 0 ]; then
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "Skipping build - no meaningful code changes detected"
              exit 0
            fi
          fi
          
          echo "should_build=true" >> $GITHUB_OUTPUT
          echo "Build will proceed - meaningful changes detected (including code and/or workflow changes)"
      
      - name: Generate semantic version
        id: version
        run: |
          # Base version from app/version.txt
          BASE_VERSION=$(cat app/version.txt | tr -d '\n\r')
          
          # Get branch info
          BRANCH_NAME="${{ github.ref_name }}"
          BRANCH_SANITIZED=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Get commit info
          COMMIT_SHORT="${{ github.sha }}"
          COMMIT_SHORT="${COMMIT_SHORT:0:7}"
          
          # Get timestamp info
          TIMESTAMP=$(date +"%Y%m%d")
          BUILD_NUMBER=$(date +"%H%M")
          
          # Determine if this is a prerelease
          IS_PRERELEASE="true"
          PRERELEASE_SUFFIX=""
          
          if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
            # Main branch = stable release
            VERSION="$BASE_VERSION"
            IS_PRERELEASE="false"
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            # Develop branch = development prerelease
            VERSION="$BASE_VERSION-dev.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="dev"
          elif [[ "$BRANCH_NAME" =~ ^(feature|feat)/ ]]; then
            # Feature branch = feature prerelease
            FEATURE_NAME=$(echo "$BRANCH_NAME" | sed 's|^.*/||' | sed 's/[^a-zA-Z0-9._-]/-/g')
            VERSION="$BASE_VERSION-feature.$FEATURE_NAME.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="feature"
          elif [[ "$BRANCH_NAME" =~ ^(hotfix|fix)/ ]]; then
            # Hotfix branch = hotfix prerelease
            VERSION="$BASE_VERSION-hotfix.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="hotfix"
          else
            # Other branches = alpha prerelease
            VERSION="$BASE_VERSION-alpha.$BRANCH_SANITIZED.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="alpha"
          fi
          
          # Create numeric version for Windows RC files (extract major.minor.patch + build number)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
          NUMERIC_VERSION="$MAJOR.$MINOR.$PATCH.$BUILD_NUMBER"
          
          # Output all versions
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "numeric_version=$NUMERIC_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          
          echo "Generated versions:"
          echo "  Semantic Version: $VERSION"
          echo "  Numeric Version: $NUMERIC_VERSION"
          echo "  Is Prerelease: $IS_PRERELEASE"
          echo "  Branch: $BRANCH_NAME"
  build-windows-dev:
    name: Windows Development Build
    needs: setup-version
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0  # Needed for version info
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
    
    - name: Install WiX Toolset
      run: |
        # Install .NET SDK first (required for WiX v5)
        choco install dotnet-sdk -y
        
        # Install WiX Toolset v5 as a .NET tool (recommended approach for v5)
        dotnet tool install --global wix --version 5.0.1
        
        # Verify installation
        wix --version
    
    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1
    
    - name: Update version file for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Write numeric version for Windows RC compilation
        echo $env:NUMERIC_VERSION > app\version.txt
        
        # Create detailed version info file for reference  
        @"
        Semantic Version: $env:SEMANTIC_VERSION
        Numeric Version: $env:NUMERIC_VERSION
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        "@ | Out-File -FilePath "build_version_info.txt" -Encoding utf8
    
    - name: Build using build-artemis-arch.bat script
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Add Qt to PATH for the build script
        $env:PATH = "$env:Qt6_DIR\bin;$env:PATH"
        
        # Run our Artemis build script that handles everything
        cmd /c "scripts\build-artemis-arch.bat release"
        
        if ($LASTEXITCODE -ne 0) {
          echo "Build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
    
    - name: Rename artifacts for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated MSI and portable ZIP files
        $msiFile = Get-ChildItem -Path "build\installer-x64-release" -Filter "*.msi" | Select-Object -First 1
        $zipFile = Get-ChildItem -Path "build\installer-x64-release" -Filter "ArtemisPortable-*.zip" | Select-Object -First 1
        
        if ($msiFile) {
          # Rename MSI installer for Artemis using semantic version
          $newMsiName = "artemis-windows-installer-$env:SEMANTIC_VERSION.msi"
          Move-Item $msiFile.FullName $newMsiName
          echo "Created MSI installer: $newMsiName"
        }
        
        if ($zipFile) {
          # Rename portable ZIP for Artemis using semantic version
          $newZipName = "artemis-windows-portable-$env:SEMANTIC_VERSION.zip"
          Move-Item $zipFile.FullName $newZipName
          echo "Created portable ZIP: $newZipName"
        }
        
        # Create info file with semantic versioning
        @"
        Artemis Desktop Development Build
        Version: $env:SEMANTIC_VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        
        This build includes:
        - MSI Installer with proper dependency handling
        - Portable ZIP package  
        - All required Windows runtime dependencies
        "@ | Out-File -FilePath "build_info.txt" -Encoding utf8
    
    - name: Upload MSI Installer
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-installer-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-installer-${{ needs.setup-version.outputs.version }}.msi
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload Portable ZIP
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-portable-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-portable-${{ needs.setup-version.outputs.version }}.zip
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload Build Info
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-build-info-${{ needs.setup-version.outputs.version }}
        path: build_info.txt
        retention-days: 30

  build-windows-arm64-dev:
    name: Windows ARM64 Development Build
    needs: setup-version
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0  # Needed for version info
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt Desktop (required for ARM64)
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
        
    - name: Setup Qt for ARM64
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}  # Use Qt 6.8.3 LTS which has ARM64 support
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_arm64_cross_compiled'  # Correct ARM64 architecture name
        set-env: false  # Don't let this override our Qt6_DIR - we'll set it manually
    
    - name: Install WiX Toolset
      run: |
        # Install .NET SDK first (required for WiX v5)
        choco install dotnet-sdk -y
        
        # Install WiX Toolset v5 as a .NET tool (recommended approach for v5)
        dotnet tool install --global wix --version 5.0.1
        
        # Verify installation
        wix --version
    
    - name: Setup MSVC for ARM64
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: amd64_arm64  # Cross-compile from x64 host to ARM64 target
        
    - name: Verify MSVC ARM64 Setup
      run: |
        echo "MSVC Environment Variables:"
        echo "VSCMD_ARG_TGT_ARCH: $env:VSCMD_ARG_TGT_ARCH"
        echo "VSCMD_ARG_HOST_ARCH: $env:VSCMD_ARG_HOST_ARCH"
        echo "Platform: $env:Platform"
        echo "LIB: $($env:LIB -split ';' | Select-Object -First 3)"
        echo "INCLUDE: $($env:INCLUDE -split ';' | Select-Object -First 3)"
    
    - name: Update version file for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Write numeric version for Windows RC compilation
        echo $env:NUMERIC_VERSION > app\version.txt
        
        # Create detailed version info file for reference  
        @"
        Semantic Version: $env:SEMANTIC_VERSION
        Numeric Version: $env:NUMERIC_VERSION
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        Architecture: ARM64
        "@ | Out-File -FilePath "build_version_info_arm64.txt" -Encoding utf8
    
    - name: Build using build-artemis-arch.bat script for ARM64
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Debug all Qt installations
        echo "All Qt installations:"
        Get-ChildItem "D:\a\artemis\Qt\6.8.3" -ErrorAction SilentlyContinue | Select-Object Name
        
        # Look for ARM64 Qt installation - try all possible names
        echo "Debugging Qt installation paths:"
        echo "Checking for Qt 6.8.3:"
        Get-ChildItem "D:\a\artemis\Qt\6.8.3" -ErrorAction SilentlyContinue | ForEach-Object { 
          echo "  Found: $($_.Name)"
          if ($_.Name -like "*arm64*") {
            echo "    ^ This looks like ARM64!"
          }
        }
        echo "Checking for Qt 6.6.3:"
        Get-ChildItem "D:\a\artemis\Qt\6.6.3" -ErrorAction SilentlyContinue | ForEach-Object { 
          echo "  Found: $($_.Name)"
          if ($_.Name -like "*arm64*") {
            echo "    ^ This looks like ARM64!"
          }
        }
        
        $possibleArm64Paths = @(
          "D:\a\artemis\Qt\6.8.3\msvc2022_arm64",
          "D:\a\artemis\Qt\6.8.3\win64_msvc2022_arm64_cross_compiled",
          "D:\a\artemis\Qt\6.8.3\msvc2022_arm64_cross_compiled",
          "D:\a\artemis\Qt\6.8.3\win64_msvc2022_arm64"
        )
        
        $arm64QtPath = $null
        foreach ($path in $possibleArm64Paths) {
          echo "Checking path: $path"
          if (Test-Path $path) {
            $arm64QtPath = $path
            echo "Found ARM64 Qt at: $arm64QtPath"
            break
          } else {
            echo "  Not found"
          }
        }
        
        # If none of the expected paths work, try to find any directory with arm64 in the name
        if (-not $arm64QtPath) {
          echo "Trying to find any ARM64 directory:"
          $arm64Dirs = @()
          
          # Check Qt 6.8.3 first
          if (Test-Path "D:\a\artemis\Qt\6.8.3") {
            $arm64Dirs += Get-ChildItem "D:\a\artemis\Qt\6.8.3" -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*arm64*" }
          }
          
          # Then check Qt 6.6.3
          if (Test-Path "D:\a\artemis\Qt\6.6.3") {
            $arm64Dirs += Get-ChildItem "D:\a\artemis\Qt\6.6.3" -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*arm64*" }
          }
          
          if ($arm64Dirs) {
            $arm64QtPath = $arm64Dirs[0].FullName
            echo "Found ARM64 Qt directory by pattern: $arm64QtPath"
          }
        }
        
        if ($arm64QtPath) {
          $env:Qt6_DIR = $arm64QtPath
          
          # CRITICAL FIX: Be very careful about PATH length to avoid "input line too long" error
          # Save original PATH and create a minimal PATH for Qt ARM64 build
          $originalPath = $env:PATH
          
          # Extract only essential Windows paths to keep PATH short
          $essentialPaths = @(
            "C:\Windows\system32",
            "C:\Windows",
            "C:\Windows\System32\Wbem",
            "C:\Windows\System32\WindowsPowerShell\v1.0\"
          )
          
          # Add MSVC paths if they exist
          $msvcPaths = $env:PATH -split ';' | Where-Object { $_ -like "*Microsoft Visual Studio*" -or $_ -like "*MSVC*" -or $_ -like "*VC\Tools*" }
          
          # Create minimal PATH with Qt ARM64 at the front
          $minimalPath = @($arm64QtPath + "\bin") + $essentialPaths + $msvcPaths -join ';'
          $env:PATH = $minimalPath
          
          echo "Reduced PATH from $($originalPath.Length) to $($env:PATH.Length) characters to avoid command line length limits"
          
        } else {
          echo "ARM64 Qt not found at any path!"
          echo "Available Qt 6.8.3 installations:"
          Get-ChildItem "D:\a\artemis\Qt\6.8.3" -ErrorAction SilentlyContinue | Select-Object Name
          echo "Available Qt 6.7.2 installations:"
          Get-ChildItem "D:\a\artemis\Qt\6.7.2" -ErrorAction SilentlyContinue | Select-Object Name
          echo "Searched paths:"
          foreach ($path in $possibleArm64Paths) {
            echo "  $path - $(if (Test-Path $path) { 'EXISTS' } else { 'NOT FOUND' })"
          }
          exit 1
        }
        
        # Debug environment before build
        echo "Qt6_DIR: $env:Qt6_DIR"
        echo "PATH length: $($env:PATH.Length) characters"
        echo "INCLUDE set: $($env:INCLUDE -ne $null)"
        echo "LIB set: $($env:LIB -ne $null)"
        echo "LIBPATH set: $($env:LIBPATH -ne $null)"
        echo "VSCMD_ARG_TGT_ARCH: $env:VSCMD_ARG_TGT_ARCH"
        echo "VSCMD_ARG_HOST_ARCH: $env:VSCMD_ARG_HOST_ARCH"
        echo "Platform: $env:Platform"
        
        # Check that we're using the correct qmake
        echo "Which qmake:"
        where qmake* 2>$null || echo "No qmake found"
        
        # Verify qmake version and path
        if (Test-Path "$env:Qt6_DIR\bin\qmake.bat") {
          echo "Using qmake.bat from: $env:Qt6_DIR\bin\qmake.bat"
        } else {
          echo "ERROR: qmake.bat not found at expected location"
          exit 1
        }
        
        # Test qmake functionality
        echo "Testing qmake:"
        & "$env:Qt6_DIR\bin\qmake.bat" -version
        if ($LASTEXITCODE -ne 0) {
          echo "ERROR: qmake test failed"
          exit 1
        }
        
        # Test MSVC environment
        echo "Testing MSVC environment:"
        echo "Checking for cl.exe:"
        where cl.exe 2>$null || echo "cl.exe not found in PATH"
        if (where cl.exe 2>$null) {
          echo "Testing cl.exe:"
          cl.exe 2>&1 | Select-String "Microsoft|Version" | Select-Object -First 2
        }
        echo "Checking for nmake.exe:"
        where nmake.exe 2>$null || echo "nmake.exe not found in PATH"
        echo "Checking for msbuild.exe:"
        where msbuild.exe 2>$null || echo "msbuild.exe not found in PATH"
        
        # Run our Artemis build script that handles everything
        echo "Running build script..."
        
        # Enable verbose output for troubleshooting
        $env:VERBOSE = "1"
        
        # Run the build script and capture detailed output
        echo "Executing: cmd /c 'scripts\build-artemis-arch.bat release'"
        cmd /c "scripts\build-artemis-arch.bat release"
        
        $buildExitCode = $LASTEXITCODE
        echo "Build script exited with code: $buildExitCode"
        
        if ($buildExitCode -ne 0) {
          echo "Build failed with exit code $buildExitCode"
          echo "Checking for any build directories that were created:"
          Get-ChildItem -Path "build" -ErrorAction SilentlyContinue | Select-Object Name
          
          # Check if there are any log files that might give us more info
          echo "Looking for build logs:"
          Get-ChildItem -Path "build" -Recurse -Filter "*.log" -ErrorAction SilentlyContinue | Select-Object FullName
          
          exit $buildExitCode
        }
        
        # Debug what was actually created
        echo "Build completed successfully. Checking output directories:"
        Get-ChildItem -Path "build" -Recurse -ErrorAction SilentlyContinue | Select-Object FullName
        
        # Specifically check for the expected build artifacts
        echo "Looking for ARM64 build artifacts:"
        Get-ChildItem -Path "build\build-arm64-release" -ErrorAction SilentlyContinue | Select-Object Name
        Get-ChildItem -Path "build\installer-arm64-release" -ErrorAction SilentlyContinue | Select-Object Name
    
    - name: Rename artifacts for ARM64 development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated MSI and portable ZIP files
        $msiFile = Get-ChildItem -Path "build\installer-arm64-release" -Filter "*.msi" | Select-Object -First 1
        $zipFile = Get-ChildItem -Path "build\installer-arm64-release" -Filter "ArtemisPortable-*.zip" | Select-Object -First 1
        
        if ($msiFile) {
          # Rename MSI installer for Artemis ARM64 using semantic version
          $newMsiName = "artemis-windows-arm64-installer-$env:SEMANTIC_VERSION.msi"
          Move-Item $msiFile.FullName $newMsiName
          echo "Created ARM64 MSI installer: $newMsiName"
        }
        
        if ($zipFile) {
          # Rename portable ZIP for Artemis ARM64 using semantic version
          $newZipName = "artemis-windows-arm64-portable-$env:SEMANTIC_VERSION.zip"
          Move-Item $zipFile.FullName $newZipName
          echo "Created ARM64 portable ZIP: $newZipName"
        }
        
        # Create info file with semantic versioning
        @"
        Artemis Desktop Development Build (ARM64)
        Version: $env:SEMANTIC_VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        Architecture: ARM64
        
        This build includes:
        - MSI Installer with proper dependency handling for Windows ARM64
        - Portable ZIP package for Windows ARM64  
        - All required Windows ARM64 runtime dependencies
        "@ | Out-File -FilePath "build_info_arm64.txt" -Encoding utf8
    
    - name: Upload ARM64 MSI Installer
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-arm64-installer-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-arm64-installer-${{ needs.setup-version.outputs.version }}.msi
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload ARM64 Portable ZIP
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-arm64-portable-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-arm64-portable-${{ needs.setup-version.outputs.version }}.zip
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload ARM64 Build Info
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-arm64-build-info-${{ needs.setup-version.outputs.version }}
        path: build_info_arm64.txt
        retention-days: 30

  build-macos-dev:
    name: macOS Development Build
    needs: setup-version
    runs-on: macos-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"

    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'mac'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install dependencies
      run: |
        brew install create-dmg ffmpeg opus sdl2 sdl2_ttf
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf soundio/Makefile* soundio/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        qmake6 artemis.pro CONFIG+=release CONFIG+=sdk_no_version_check
        make -j$(sysctl -n hw.ncpu)
    
    - name: Package macOS Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Deploy Qt frameworks to the app bundle
        echo "Deploying Qt frameworks using macdeployqt..."
        macdeployqt app/Artemis.app -qmldir=app/gui -appstore-compliant || {
          echo "macdeployqt failed with -appstore-compliant, trying without"
          macdeployqt app/Artemis.app -qmldir=app/gui
        }
        
        # Verify frameworks were bundled
        echo "Checking bundled frameworks:"
        ls -la app/Artemis.app/Contents/Frameworks/ || echo "No Frameworks directory found"
        
        # Verify the app can find its dependencies
        echo "Checking app dependencies:"
        otool -L app/Artemis.app/Contents/MacOS/Artemis | head -20
        
        # Test that the app bundle structure is correct
        echo "App bundle structure:"
        find app/Artemis.app -name "*.framework" | head -10
        
        # Check and fix permissions
        echo "Setting proper permissions..."
        chmod -R 755 app/Artemis.app
        chmod +x app/Artemis.app/Contents/MacOS/Artemis
        
        # Check for any signing that might have been applied
        echo "Checking code signing status:"
        codesign -dv app/Artemis.app 2>&1 || echo "App is not code signed"
        
        # Remove quarantine attributes that might interfere
        echo "Removing quarantine attributes..."
        xattr -cr app/Artemis.app || echo "No quarantine attributes to remove"
        
        # For development builds, add a simple ad-hoc signature to prevent "damaged" errors
        echo "Applying ad-hoc code signature for development..."
        codesign --force --deep --sign - app/Artemis.app || echo "Ad-hoc signing failed, continuing anyway"
        
        # Verify the signature was applied
        echo "Verifying signature:"
        codesign -dv app/Artemis.app 2>&1 || echo "No signature found"
        
        # Create info file with semantic versioning
        cat > build_info.txt << EOF
        Artemis Desktop Development Build
        Version: $VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        
        Installation Notes:
        - If macOS says the app is "damaged", run: xattr -cr Artemis.app
        - Or go to System Preferences > Security & Privacy and allow the app
        - This is a development build and may trigger Gatekeeper warnings
        EOF
        
        # Package with semantic version including the properly bundled app
        tar -czf artemis-macos-$VERSION.tar.gz -C app Artemis.app -C .. build_info.txt
    
    - name: Upload Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-macos-${{ needs.setup-version.outputs.version }}
        path: artemis-macos-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  build-linux-dev:
    name: Linux Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0

    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        qmake6 artemis.pro CONFIG+=release
        make -j$(nproc)
    
    - name: Package Linux Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Create info file with semantic versioning
        cat > build_info.txt << EOF
        Artemis Desktop Development Build
        Version: $VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        EOF
        
        # Package with semantic version
        tar -czf artemis-linux-$VERSION.tar.gz -C app artemis -C .. build_info.txt
    - name: Upload Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-linux-${{ needs.setup-version.outputs.version }}
        path: artemis-linux-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  build-appimage-dev:
    name: AppImage Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev file wget desktop-file-utils \
          libxcb-cursor-dev
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf soundio/Makefile* soundio/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        # Clean any problematic files
        rm -rf AntiHooking/ || true
        rm -rf config.tests/SL/ || true
        rm -f app/test_*.cpp || true
        # Build with proper configuration
        qmake6 artemis.pro CONFIG+=release
        make -j$(nproc)
    
    - name: Verify build output
      run: |
        ls -la app/
        file app/artemis || echo "artemis binary not found"
        ldd app/artemis || echo "ldd failed"
    
    - name: Create AppImage
      env:
          VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Download linuxdeploy and Qt plugin
        wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
        wget -q https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage
        chmod +x linuxdeploy*.AppImage
        
        # Create AppDir structure
        mkdir -p AppDir/usr/bin
        cp app/artemis AppDir/usr/bin/artemis-dev
        
        # Create desktop file
        cat > AppDir/artemis-dev.desktop << 'EOF'
        [Desktop Entry]
        Type=Application
        Name=Artemis Desktop (Dev)
        Comment=Artemis Desktop Development Build
        Exec=artemis-dev
        Icon=artemis-dev
        Categories=Game;Network;
        StartupNotify=true
        EOF
        
        # Create a simple icon placeholder
        mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
        convert -size 256x256 xc:blue -fill white -gravity center -pointsize 24 -annotate +0+0 "Artemis\nDev" AppDir/usr/share/icons/hicolor/256x256/apps/artemis-dev.png 2>/dev/null || {
          echo "Creating placeholder icon"
          touch AppDir/usr/share/icons/hicolor/256x256/apps/artemis-dev.png
        }
        
        # Create build info
        cat > AppDir/build_info.txt << EOF
        Artemis Desktop Development Build (AppImage)
        Version: $VERSION
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date)
        EOF
        
        # Set environment variables for linuxdeploy
        export OUTPUT="artemis-appimage-${VERSION}-x86_64.AppImage"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        export QML_SOURCES_PATH="$Qt6_DIR/qml"

        # Build AppImage
        ./linuxdeploy-x86_64.AppImage \
          --appdir AppDir \
          --executable AppDir/usr/bin/artemis-dev \
          --desktop-file AppDir/artemis-dev.desktop \
          --plugin qt \
          --output appimage
        
        # Verify and rename if necessary
        ls -la *.AppImage || echo "No AppImage files found"
        if [ ! -f "$OUTPUT" ]; then
          APPIMAGE_FILE=$(ls *.AppImage | head -n1)
          if [ -n "$APPIMAGE_FILE" ]; then
            mv "$APPIMAGE_FILE" "$OUTPUT"
            echo "Renamed $APPIMAGE_FILE to $OUTPUT"
          else
            echo "Error: No AppImage file was created"
            exit 1
          fi
        fi
        
        # Final verification
        chmod +x "$OUTPUT"
        ls -la "$OUTPUT"
        file "$OUTPUT"
    
    - name: Upload AppImage Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-appimage-${{ needs.setup-version.outputs.version }}
        path: artemis-appimage-${{ needs.setup-version.outputs.version }}-x86_64.AppImage
        retention-days: 30

  build-flatpak-dev:
    name: Flatpak Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Install Flatpak and dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y flatpak flatpak-builder
        sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
        sudo flatpak install -y flathub org.freedesktop.Platform//23.08 org.freedesktop.Sdk//23.08 org.kde.Platform//6.6 org.kde.Sdk//6.6
    
    - name: Create Flatpak manifest
      run: |
        cat > com.artemisdesktop.ArtemisDesktopDev.yml << 'EOF'
        app-id: com.artemisdesktop.ArtemisDesktopDev
        runtime: org.kde.Platform
        runtime-version: '6.6'
        sdk: org.kde.Sdk
        command: artemis-dev
        finish-args:
          - --share=ipc
          - --socket=x11
          - --socket=wayland
          - --socket=pulseaudio
          - --share=network
          - --device=all
          - --filesystem=home
        modules:
          - name: opus
            sources:
              - type: archive
                url: https://downloads.xiph.org/releases/opus/opus-1.4.tar.gz
                sha256: c9b32b4253be5ae63d1ff16eea06b94b5f0f2951b7a02aceef58e3a3ce49c51f
          
          - name: sdl2
            sources:
              - type: archive
                url: https://github.com/libsdl-org/SDL/releases/download/release-2.28.5/SDL2-2.28.5.tar.gz
                sha256: 332cb37d0be20cb9541739c61f79bae5a477427d79ae85e352089afdaf6666e4
          
          - name: sdl2-ttf
            sources:
              - type: archive
                url: https://github.com/libsdl-org/SDL_ttf/releases/download/release-2.20.2/SDL2_ttf-2.20.2.tar.gz
                sha256: 9dc71ed93487521b107a2c4a9ca6bf43fb62f6bddd5c26b055e6b91418a22053
          
          - name: artemis-desktop-dev
            buildsystem: simple
            build-commands:
              - rm -f .qmake.stash .qmake.cache
              - find . -name "Makefile*" -delete || true
              - rm -rf AntiHooking/ || true
              - rm -rf config.tests/SL/ || true
              - rm -f app/test_*.cpp || true
              - qmake6 artemis.pro CONFIG+=release
              - make -j$(nproc)
              - install -Dm755 app/artemis /app/bin/artemis-dev
            sources:
              - type: dir
                path: .
            post-install:
              - |
                install -Dm644 /dev/stdin /app/share/applications/com.artemisdesktop.ArtemisDesktopDev.desktop << 'EOD'
                [Desktop Entry]
                Type=Application
                Name=Artemis Desktop (Dev)
                Comment=Artemis Desktop Development Build
                Exec=artemis-dev
                Icon=com.artemisdesktop.ArtemisDesktopDev
                Categories=Game;Network;
                EOD
        EOF
    
    - name: Build Flatpak
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        flatpak-builder --force-clean --repo=repo build-dir com.artemisdesktop.ArtemisDesktopDev.yml
        flatpak build-bundle repo artemis-flatpak-$VERSION.flatpak com.artemisdesktop.ArtemisDesktopDev
    
    - name: Upload Flatpak Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-flatpak-${{ needs.setup-version.outputs.version }}
        path: artemis-flatpak-${{ needs.setup-version.outputs.version }}.flatpak
        retention-days: 30

  build-steamdeck-dev:
    name: Steam Deck Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install Steam Deck specific dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev
    
    - name: Build for Steam Deck
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        # Build with Steam Deck optimizations
        qmake6 artemis.pro CONFIG+=release CONFIG+=steamdeck
        make -j$(nproc)
    
    - name: Package Steam Deck Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        mkdir -p steamdeck-package
        cp app/artemis steamdeck-package/artemis-dev
        
        # Create Steam Deck specific files
        cat > steamdeck-package/artemis-dev.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=Artemis Desktop (Dev)
        Comment=Artemis Desktop Development Build - Optimized for Steam Deck
        Exec=artemis-dev
        Icon=artemis-dev
        Categories=Game;Network;
        EOF
        
        # Create installation script for Steam Deck
        cat > steamdeck-package/install-steamdeck.sh << 'EOF'
        #!/bin/bash
        echo "Installing Artemis Desktop Development Build for Steam Deck..."
        
        # Create directories
        mkdir -p ~/.local/share/applications
        mkdir -p ~/.local/bin
        
        # Copy files
        cp artemis-dev ~/.local/bin/
        chmod +x ~/.local/bin/artemis-dev
        cp artemis-dev.desktop ~/.local/share/applications/
        
        echo "Installation complete!"
        echo "You can now find Artemis Desktop (Dev) in your applications menu."
        EOF
        
        chmod +x steamdeck-package/install-steamdeck.sh
        
        # Create build info
        cat > steamdeck-package/build_info.txt << EOF
        Artemis Desktop Development Build (Steam Deck)
        Version: $VERSION
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date)
        
        Installation:
        1. Extract this archive
        2. Run: ./install-steamdeck.sh
        3. Find Artemis Desktop (Dev) in your applications
        EOF
        
        # Create README for Steam Deck users
        cat > steamdeck-package/README-SteamDeck.md << EOF
        # Artemis Desktop for Steam Deck (Development Build)
        
        ## Installation
        1. Extract this archive to a folder
        2. Open a terminal in that folder
        3. Run: \`./install-steamdeck.sh\`
        4. The app will be available in your applications menu
        
        ## Steam Deck Specific Notes
        - This build is optimized for Steam Deck's controls and display
        - Use the touchscreen or external mouse/keyboard for initial setup
        - Game mode streaming works best with the built-in controls
        
        ## Troubleshooting
        - If you have issues, try running from terminal: \`~/.local/bin/artemis-dev\`
        - Check the build_info.txt for version details
        EOF
        
        tar -czf artemis-steamdeck-$VERSION.tar.gz -C steamdeck-package .
    
    - name: Upload Steam Deck Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-steamdeck-${{ needs.setup-version.outputs.version }}
        path: artemis-steamdeck-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  create-dev-release:
    name: Create Development Release
    needs: [setup-version, build-windows-dev, build-windows-arm64-dev, build-macos-dev, build-linux-dev, build-appimage-dev, build-flatpak-dev, build-steamdeck-dev]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && needs.setup-version.outputs.should_build == 'true'  # Create releases for develop/main branches when builds ran
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for changelog
    
    - name: Display release version info
      run: |
        echo "Creating release with version: ${{ needs.setup-version.outputs.version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"

    - name: Create tag for release
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag ${{ needs.setup-version.outputs.version }}
        git push origin ${{ needs.setup-version.outputs.version }}

    - name: Generate Changelog
      id: changelog
      run: |
        CURRENT_VERSION="${{ needs.setup-version.outputs.version }}"
        PREV_TAG=$(git tag --sort=-creatordate | grep -v "$CURRENT_VERSION" | head -n1)
        if [ -z "$PREV_TAG" ]; then
          SINCE_DATE=$(date -d '7 days ago' '+%Y-%m-%d')
          echo "No previous release found. Getting commits since $SINCE_DATE"
          COMMITS=$(git log --since="$SINCE_DATE" --pretty=format:"%h|%s|%an|%ad" --date=short --no-merges)
        else
          echo "Getting commits since last release: $PREV_TAG"
          COMMITS=$(git log ${PREV_TAG}..$CURRENT_VERSION --pretty=format:"%h|%s|%an|%ad" --date=short --no-merges)
        fi
        FEATURES=""
        BUGFIXES=""
        IMPROVEMENTS=""
        OTHER=""
        while IFS='|' read -r hash subject author date; do
          if [ -z "$hash" ]; then continue; fi
          subject=$(echo "$subject" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          if echo "$subject" | grep -iE "^(feat|feature|add|implement|new)[:|\s]" > /dev/null; then
            FEATURES="${FEATURES}- ${subject} (${hash})\n"
          elif echo "$subject" | grep -iE "^(fix|bug|resolve|correct)[:|\s]" > /dev/null; then
            BUGFIXES="${BUGFIXES}- ${subject} (${hash})\n"
          elif echo "$subject" | grep -iE "^(improve|enhance|update|optimize|refactor)[:|\s]" > /dev/null; then
            IMPROVEMENTS="${IMPROVEMENTS}- ${subject} (${hash})\n"
          else
            OTHER="${OTHER}- ${subject} (${hash})\n"
          fi
        done <<< "$COMMITS"
        CHANGELOG="##  Development Build Changelog\n\n"
        [ ! -z "$FEATURES" ] && CHANGELOG="${CHANGELOG}###  New Features\n${FEATURES}\n"
        [ ! -z "$BUGFIXES" ] && CHANGELOG="${CHANGELOG}###  Bug Fixes\n${BUGFIXES}\n"
        [ ! -z "$IMPROVEMENTS" ] && CHANGELOG="${CHANGELOG}###  Improvements\n${IMPROVEMENTS}\n"
        [ ! -z "$OTHER" ] && CHANGELOG="${CHANGELOG}###  Other Changes\n${OTHER}\n"
        echo -e "$CHANGELOG" > changelog.md
        echo "Generated changelog:"
        cat changelog.md
        {
          echo 'changelog<<EOF'
          cat changelog.md
          echo EOF
        } >> $GITHUB_OUTPUT
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Check if artifacts exist (handle build skipping scenario)
      id: check-artifacts
      run: |
        if [ -d "artifacts" ] && [ "$(ls -A artifacts)" ]; then
          echo "artifacts_exist=true" >> $GITHUB_OUTPUT
          echo "Artifacts found - proceeding with release"
        else
          echo "artifacts_exist=false" >> $GITHUB_OUTPUT
          echo "No artifacts found - builds were skipped"
          echo "Will attempt to find and link to previous build with same commit"
          
          # Try to find a previous release with the same commit hash
          COMMIT_HASH="${{ github.sha }}"
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "Looking for existing artifacts with commit: $COMMIT_HASH"
        fi

    - name: Find and download previous artifacts if builds were skipped
      id: find-previous
      if: steps.check-artifacts.outputs.artifacts_exist == 'false'
      run: |
        echo "Searching for previous release with commit ${{ steps.check-artifacts.outputs.commit_hash }}"
        
        # Use GitHub API to find releases
        RELEASES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/releases?per_page=50")
        
        # Look for a release with matching commit (in tag or body)
        MATCHING_RELEASE=$(echo "$RELEASES" | jq -r '.[] | select(.body | contains("${{ steps.check-artifacts.outputs.commit_hash }}")) | .tag_name' | head -n1)
        
        if [ -n "$MATCHING_RELEASE" ] && [ "$MATCHING_RELEASE" != "null" ]; then
          echo "Found matching release: $MATCHING_RELEASE"
          echo "previous_release_tag=$MATCHING_RELEASE" >> $GITHUB_OUTPUT
          
          # Download assets from the matching release
          mkdir -p reused-artifacts
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$MATCHING_RELEASE")
          
          # Download all assets
          echo "$RELEASE_INFO" | jq -r '.assets[].browser_download_url' | while read -r url; do
            if [ -n "$url" ]; then
              filename=$(basename "$url")
              echo "Downloading: $filename"
              curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -o "reused-artifacts/$filename" "$url"
            fi
          done
          
          echo "reused_artifacts_available=true" >> $GITHUB_OUTPUT
          ls -la reused-artifacts/
        else
          echo "No matching release found with commit ${{ steps.check-artifacts.outputs.commit_hash }}"
          echo "reused_artifacts_available=false" >> $GITHUB_OUTPUT
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: List downloaded files for debugging
      if: steps.check-artifacts.outputs.artifacts_exist == 'true'
      run: ls -R artifacts
      
    - name: List reused artifacts for debugging
      if: steps.check-artifacts.outputs.artifacts_exist == 'false'
      run: |
        if [ -d "reused-artifacts" ]; then
          echo "Reused artifacts found:"
          ls -la reused-artifacts/
        else
          echo "No reused artifacts available"
        fi
    
    - name: Create Development Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.setup-version.outputs.version }}
        name: "${{ (github.ref_name == 'main' || github.ref_name == 'master') && ' Production Release' || ' Development Build' }} ${{ needs.setup-version.outputs.version }}"
        body: |
          ${{ (github.ref_name == 'main' || github.ref_name == 'master') && ' **Production Release** 

          This is an official production release of Artemis Desktop.

          ** Stable**: This release has been tested and is recommended for general use.' || ' **Development Build** 
          
          This is an automated development build from the `develop` branch.
          
          ** Warning**: Development builds are unstable and intended for testing purposes only. Use at your own risk!' }}
          
          ---
          
          ${{ steps.changelog.outputs.changelog }}
          
          ---
          
          ##  Build Information
          - **Version**: `${{ needs.setup-version.outputs.version }}`
          - **Numeric Version**: `${{ needs.setup-version.outputs.numeric_version }}`
          - **Branch**: `${{ github.ref_name }}`
          - **Commit**: `${{ github.sha }}`
          - **Build**: #${{ github.run_number }}
          
          ##  Installation
          ${{ (steps.check-artifacts.outputs.artifacts_exist == 'true' || steps.find-previous.outputs.reused_artifacts_available == 'true') && '1. Download the appropriate file for your platform
          2. Extract the archive (if applicable)
          3. Run the executable (may require additional setup on some platforms)' || 'No installation files are available for this release. Please check recent releases or feature branches for builds.' }}
          
          ##  Found a Bug?
          Please report issues on our [GitHub Issues](https://github.com/${{ github.repository }}/issues) page.
        files: |
          ${{ steps.check-artifacts.outputs.artifacts_exist == 'true' && 'artifacts/*/*' || '' }}
          ${{ steps.check-artifacts.outputs.artifacts_exist == 'false' && 'reused-artifacts/*' || '' }}
        prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        draft: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}