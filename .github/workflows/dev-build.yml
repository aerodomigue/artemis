name: Development Build

# This workflow handles development builds with intelligent build skipping:
# - Feature branches: Build artifacts, no releases (testing only)  
# - Develop branch: Build artifacts + create development releases (when meaningful changes are merged)
# - Main/Master branch: ALWAYS build + create production releases (releases require fresh artifacts)
#
# Smart merge detection prevents redundant builds by:
# - Main/Master: Always builds (never skip releases!)
# - Detecting merge commits vs regular commits
# - For merges: Analyzing actual changes being merged (not just the merge commit)
# - For regular commits: Comparing against previous commit
# - Skipping builds when only documentation/config files changed (.md, .txt, .yml, .yaml, .github/)
# - Respecting [skip ci] or [ci skip] in commit messages (except on main/master)
#
# This ensures develop/main branches BUILD when feature branches are merged (as they should!)
# while still preventing redundant builds when no meaningful code changes exist.

on:
  push:
    branches: 
      - develop
      - dev
      - main
      - master
      - 'feature/**'
      - 'feat/**'
      - 'fix/**'
  workflow_dispatch:  # Allow manual triggering

env:
  QT_VERSION: '6.8.3'

jobs:
  setup-version:
    name: Setup Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      numeric_version: ${{ steps.version.outputs.numeric_version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      should_build: ${{ steps.check-changes.outputs.should_build }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for proper versioning
      
      - name: Check for meaningful changes
        id: check-changes
        run: |
          # Always build on main/master branch (releases)
          if [[ "${{ github.ref_name }}" == "main" || "${{ github.ref_name }}" == "master" ]]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Always building on main/master branch for release"
            exit 0
          fi
          
          # Skip builds if commit message contains [skip ci] or [ci skip]
          if echo "${{ github.event.head_commit.message }}" | grep -E "\[(skip ci|ci skip)\]" > /dev/null; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "Build skipped due to [skip ci] in commit message"
            exit 0
          fi
          
          # Check if this is a merge commit (has multiple parents)
          PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
          PARENT_COUNT=$((PARENT_COUNT - 1))  # Subtract 1 because first item is the commit hash itself
          
          if [ "$PARENT_COUNT" -gt 1 ]; then
            echo "Detected merge commit with $PARENT_COUNT parents"
            
            # For merge commits, check the actual changes being merged
            # Compare against the first parent (the target branch before merge)
            FIRST_PARENT=$(git rev-parse HEAD^1)
            echo "Comparing changes against first parent: $FIRST_PARENT"
            
            # Get all changed files in this merge, excluding documentation/config files but allowing workflow changes
            CHANGED_FILES=$(git diff --name-only $FIRST_PARENT HEAD | grep -v -E "(\.md$|test.*\.txt$|README.*\.txt$|CHANGELOG.*\.txt$)" | grep -v -E "(\.yml$|\.yaml$)" | wc -l)
            WORKFLOW_FILES=$(git diff --name-only $FIRST_PARENT HEAD | grep -E "^\.github/workflows/.*\.(yml|yaml)$" | wc -l)
            TOTAL_MEANINGFUL=$((CHANGED_FILES + WORKFLOW_FILES))
            echo "Meaningful files changed in merge: $CHANGED_FILES"
            echo "Workflow files changed: $WORKFLOW_FILES"
            echo "Total meaningful changes: $TOTAL_MEANINGFUL"
            
            if [ "$TOTAL_MEANINGFUL" -eq 0 ]; then
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "Skipping build - merge contains no meaningful code changes"
              exit 0
            else
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "Build will proceed - merge contains $TOTAL_MEANINGFUL meaningful changes (code: $CHANGED_FILES, workflows: $WORKFLOW_FILES)"
              exit 0
            fi
          else
            echo "Regular commit (not a merge) - checking for meaningful changes"
            
            # For regular commits, check against previous commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep -v -E "(\.md$|test.*\.txt$|README.*\.txt$|CHANGELOG.*\.txt$)" | grep -v -E "(\.yml$|\.yaml$)" | wc -l)
            WORKFLOW_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E "^\.github/workflows/.*\.(yml|yaml)$" | wc -l)
            TOTAL_MEANINGFUL=$((CHANGED_FILES + WORKFLOW_FILES))
            echo "Meaningful files changed: $CHANGED_FILES"
            echo "Workflow files changed: $WORKFLOW_FILES" 
            echo "Total meaningful changes: $TOTAL_MEANINGFUL"
            
            if [ "$TOTAL_MEANINGFUL" -eq 0 ]; then
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "Skipping build - no meaningful code changes detected"
              exit 0
            fi
          fi
          
          echo "should_build=true" >> $GITHUB_OUTPUT
          echo "Build will proceed - meaningful changes detected (including code and/or workflow changes)"
      
      - name: Generate semantic version
        id: version
        run: |
          # Base version from app/version.txt
          BASE_VERSION=$(cat app/version.txt | tr -d '\n\r')
          
          # Get branch info
          BRANCH_NAME="${{ github.ref_name }}"
          BRANCH_SANITIZED=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Get commit info
          COMMIT_SHORT="${{ github.sha }}"
          COMMIT_SHORT="${COMMIT_SHORT:0:7}"
          
          # Get timestamp info
          TIMESTAMP=$(date +"%Y%m%d")
          BUILD_NUMBER=$(date +"%H%M")
          
          # Determine if this is a prerelease
          IS_PRERELEASE="true"
          PRERELEASE_SUFFIX=""
          
          if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
            # Main branch = stable release
            VERSION="$BASE_VERSION"
            IS_PRERELEASE="false"
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            # Develop branch = development prerelease
            VERSION="$BASE_VERSION-dev.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="dev"
          elif [[ "$BRANCH_NAME" =~ ^(feature|feat)/ ]]; then
            # Feature branch = feature prerelease
            FEATURE_NAME=$(echo "$BRANCH_NAME" | sed 's|^.*/||' | sed 's/[^a-zA-Z0-9._-]/-/g')
            VERSION="$BASE_VERSION-feature.$FEATURE_NAME.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="feature"
          elif [[ "$BRANCH_NAME" =~ ^(hotfix|fix)/ ]]; then
            # Hotfix branch = hotfix prerelease
            VERSION="$BASE_VERSION-hotfix.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="hotfix"
          else
            # Other branches = alpha prerelease
            VERSION="$BASE_VERSION-alpha.$BRANCH_SANITIZED.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="alpha"
          fi
          
          # Create numeric version for Windows RC files (extract major.minor.patch + build number)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
          NUMERIC_VERSION="$MAJOR.$MINOR.$PATCH.$BUILD_NUMBER"
          
          # Output all versions
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "numeric_version=$NUMERIC_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          
          echo "Generated versions:"
          echo "  Semantic Version: $VERSION"
          echo "  Numeric Version: $NUMERIC_VERSION"
          echo "  Is Prerelease: $IS_PRERELEASE"
          echo "  Branch: $BRANCH_NAME"
  build-windows-x64-portable:
    name: Windows x64 Portable Build
    needs: setup-version
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0  # Needed for version info
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
      continue-on-error: true
      id: qt_install_primary
    
    - name: Retry Qt Installation (if failed)
      if: steps.qt_install_primary.outcome == 'failure'
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
    
    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1
    
    - name: Update version file for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Write numeric version for Windows RC compilation
        echo $env:NUMERIC_VERSION > app\version.txt
    
    - name: Build portable package only
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Add Qt to PATH for the build script
        $env:PATH = "$env:Qt6_DIR\bin;$env:PATH"
        
        # Run our Artemis build script that handles everything
        cmd /c "scripts\build-artemis-arch.bat release"
        
        if ($LASTEXITCODE -ne 0) {
          echo "Build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
    
    - name: Rename portable ZIP
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated portable ZIP file
        $zipFile = Get-ChildItem -Path "build\installer-x64-release" -Filter "ArtemisPortable-*.zip" | Select-Object -First 1
        
        if ($zipFile) {
          # Rename portable ZIP for Artemis using semantic version
          $newZipName = "artemis-windows-x64-portable-$env:SEMANTIC_VERSION.zip"
          Move-Item $zipFile.FullName $newZipName
          echo "Created x64 portable ZIP: $newZipName"
        } else {
          echo "ERROR: Portable ZIP not found"
          Get-ChildItem -Path "build\installer-x64-release" -Recurse
          exit 1
        }
    
    - name: Upload x64 Portable ZIP
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-x64-portable-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-x64-portable-${{ needs.setup-version.outputs.version }}.zip
        retention-days: 30
        if-no-files-found: warn

  build-windows-arm64-portable:
    name: Windows ARM64 Portable Build
    needs: setup-version
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0  # Needed for version info
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt Desktop (required for ARM64)
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
      continue-on-error: true
      id: qt_install_desktop
        
    - name: Setup Qt for ARM64
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}  # Use Qt 6.8.3 LTS which has ARM64 support
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_arm64_cross_compiled'  # Correct ARM64 architecture name
        set-env: false  # Don't let this override our Qt6_DIR - we'll set it manually
      continue-on-error: true
      id: qt_install_arm64
    
    - name: Retry Qt Desktop Installation (if failed)
      if: steps.qt_install_desktop.outcome == 'failure'
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
    
    - name: Retry Qt ARM64 Installation (if failed)
      if: steps.qt_install_arm64.outcome == 'failure'
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_arm64_cross_compiled'
        set-env: false
    
    - name: Setup MSVC for ARM64
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: amd64_arm64  # Cross-compile from x64 host to ARM64 target
        
    - name: Verify MSVC ARM64 Setup
      run: |
        echo "MSVC Environment Variables:"
        echo "VSCMD_ARG_TGT_ARCH: $env:VSCMD_ARG_TGT_ARCH"
        echo "VSCMD_ARG_HOST_ARCH: $env:VSCMD_ARG_HOST_ARCH"
        echo "Platform: $env:Platform"
        echo "LIB: $($env:LIB -split ';' | Select-Object -First 3)"
        echo "INCLUDE: $($env:INCLUDE -split ';' | Select-Object -First 3)"
    
    - name: Update version file for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Write numeric version for Windows RC compilation
        echo $env:NUMERIC_VERSION > app\version.txt
    
    - name: Build ARM64 portable package only
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find and set up Qt ARM64 environment
        echo "Setting up Qt ARM64 environment..."
        $qtArm64Path = "D:\a\artemis\Qt\6.8.3\msvc2022_arm64"
        
        if (-not (Test-Path $qtArm64Path)) {
          echo "ERROR: Qt ARM64 not found at expected path: $qtArm64Path"
          echo "Available Qt installations:"
          Get-ChildItem "D:\a\artemis\Qt\6.8.3" -ErrorAction SilentlyContinue | Select-Object Name
          exit 1
        }
        
        # Set Qt environment
        $env:Qt6_DIR = $qtArm64Path
        $env:PATH = "$qtArm64Path\bin;$env:PATH"
        
        echo "Qt ARM64 setup complete:"
        echo "  Qt6_DIR: $env:Qt6_DIR"
        echo "  qmake available: $(Test-Path "$qtArm64Path\bin\qmake.bat")"
        
        # Run the build script
        echo "Running build script for ARM64..."
        cmd /c "scripts\build-artemis-arch.bat release"
        
        $buildExitCode = $LASTEXITCODE
        echo "Build script completed with exit code: $buildExitCode"
        
        if ($buildExitCode -ne 0) {
          echo "ERROR: Build script failed with exit code $buildExitCode"
          exit $buildExitCode
        }
    
    - name: Rename ARM64 portable ZIP
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated portable ZIP file
        $zipFile = Get-ChildItem -Path "build\installer-arm64-release" -Filter "ArtemisPortable-*.zip" | Select-Object -First 1
        
        if ($zipFile) {
          # Rename portable ZIP for Artemis ARM64 using semantic version
          $newZipName = "artemis-windows-arm64-portable-$env:SEMANTIC_VERSION.zip"
          Move-Item $zipFile.FullName $newZipName
          echo "Created ARM64 portable ZIP: $newZipName"
        } else {
          echo "ERROR: ARM64 Portable ZIP not found"
          Get-ChildItem -Path "build\installer-arm64-release" -Recurse
          exit 1
        }
    
    - name: Upload ARM64 Portable ZIP
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-arm64-portable-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-arm64-portable-${{ needs.setup-version.outputs.version }}.zip
        retention-days: 30
        if-no-files-found: warn

  build-windows-universal-installer:
    name: Windows Universal Installer
    needs: setup-version
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
      continue-on-error: true
      id: qt_install_universal_desktop
        
    - name: Setup Qt for ARM64
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_arm64_cross_compiled'
        set-env: false
      continue-on-error: true
      id: qt_install_universal_arm64
    
    - name: Retry Qt Desktop Installation (if failed)
      if: steps.qt_install_universal_desktop.outcome == 'failure'
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
    
    - name: Retry Qt ARM64 Installation (if failed)
      if: steps.qt_install_universal_arm64.outcome == 'failure'
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_arm64_cross_compiled'
        set-env: false
    
    - name: Setup build environment
      run: |
        # Install .NET SDK first (required for WiX v5)
        choco install dotnet-sdk -y
        
        # Install WiX Toolset v5 as a .NET tool (recommended approach for v5)
        dotnet tool install --global wix --version 5.0.1
        
        # Verify installation
        wix --version
        
        # Also install Visual Studio Build Tools (includes MSBuild) for compatibility
        choco install visualstudio2022buildtools --package-parameters "--includeRecommended --includeOptional --quiet --wait" -y
    
    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1
    
    - name: Setup MSVC for ARM64
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: amd64_arm64
    
    - name: Update version file
      env:
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        echo $env:NUMERIC_VERSION > app\version.txt

    - name: Build x64 MSI
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        $env:PATH = "$env:Qt6_DIR\bin;$env:PATH"
        cmd /c "scripts\build-artemis-arch.bat release"
        
        if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
        
        # Ensure MSI was created
        $msiFile = Get-ChildItem -Path "build\installer-x64-release" -Filter "*.msi" | Select-Object -First 1
        if (-not $msiFile) {
          echo "ERROR: x64 MSI not found in build\installer-x64-release"
          exit 1
        }
        
        echo "x64 MSI created successfully: $($msiFile.FullName)"
    
    - name: Build ARM64 MSI
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Set up Qt ARM64 environment
        $qtArm64Path = "D:\a\artemis\Qt\6.8.3\msvc2022_arm64"
        $env:Qt6_DIR = $qtArm64Path
        $env:PATH = "$qtArm64Path\bin;$env:PATH"
        
        cmd /c "scripts\build-artemis-arch.bat release"
        
        if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
        
        # Ensure MSI was created
        $msiFile = Get-ChildItem -Path "build\installer-arm64-release" -Filter "*.msi" | Select-Object -First 1
        if (-not $msiFile) {
          echo "ERROR: ARM64 MSI not found in build\installer-arm64-release"
          exit 1
        }
        
        echo "ARM64 MSI created successfully: $($msiFile.FullName)"
    
    - name: Generate Universal Bundle  
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Prefer a purely numeric version for MSBuild/NuGet and WiX
        $msbuildVersion = $env:NUMERIC_VERSION
        if ([string]::IsNullOrWhiteSpace($msbuildVersion)) {
          # Fallback: extract up to 4 numeric segments from semantic version
          $match = [regex]::Match($env:SEMANTIC_VERSION, '\d+(?:\.\d+){2,3}')
          if ($match.Success) { $msbuildVersion = $match.Value } else { $msbuildVersion = '0.0.0.0' }
        }
        
        echo "Original semantic version: $env:SEMANTIC_VERSION"
        echo "MSBuild/WiX version: $msbuildVersion"
        
        # Update version file with MSBuild-compatible version
        echo $msbuildVersion > app\version.txt
        
        # Set environment variables that the WiX scripts expect
        $env:BUILD_CONFIG = "release"
        $env:BUILD_ROOT = $PWD
        
        # Restore and build with explicit version properties for WiX v5
        dotnet restore wix\ArtemisSetup\ArtemisSetup.wixproj
        
        $buildCmd = "dotnet build wix\ArtemisSetup\ArtemisSetup.wixproj --configuration Release --no-restore"
        $buildCmd += " -p:INSTALLER_FOLDER=build\installer-release"
        $buildCmd += " -p:BUILD_FOLDER=build\build-release"
        $buildCmd += " -p:BUILD_ROOT=$env:BUILD_ROOT"
        $buildCmd += " -p:Version=$msbuildVersion -p:WixVersion=$msbuildVersion -p:WixBundleVersion=$msbuildVersion"
        
        Write-Host "Running: $buildCmd"
        cmd /c $buildCmd
        
        if ($LASTEXITCODE -ne 0) {
          echo "Bundle generation failed with exit code $LASTEXITCODE"
          echo "Trying fallback approach with generate-artemis-bundle.bat script..."
          
          # Fallback to original script approach with version override
          cmd /c "scripts\generate-artemis-bundle.bat release $msbuildVersion"
          
          if ($LASTEXITCODE -ne 0) {
            echo "Fallback also failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
        }
    
    - name: Rename universal bundle
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated bundle
        $bundleFile = Get-ChildItem -Path "build\installer-release" -Filter "ArtemisSetup*.exe" | Select-Object -First 1
        
        if ($bundleFile) {
          # Rename universal bundle
          $newBundleName = "artemis-windows-universal-installer-$env:SEMANTIC_VERSION.exe"
          Move-Item $bundleFile.FullName $newBundleName
          echo "Created universal installer: $newBundleName"
        } else {
          echo "ERROR: Universal bundle not found"
          Get-ChildItem -Path "build\installer-release" -Recurse
          exit 1
        }
    
    - name: Upload Universal Installer
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-universal-installer-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-universal-installer-${{ needs.setup-version.outputs.version }}.exe
        retention-days: 30
        if-no-files-found: warn

  build-macos-dev:
    name: macOS Development Build
    needs: setup-version
    runs-on: macos-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"

    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'mac'
        target: 'desktop'
        modules: 'qtmultimedia'
        
    - name: Set macOS deployment target for compatibility
      run: |
        echo "MACOSX_DEPLOYMENT_TARGET=14.0" >> $GITHUB_ENV
        echo "Qt6_DIR=$Qt6_DIR" >> $GITHUB_ENV
    
    - name: Install dependencies
      run: |
        brew install create-dmg ffmpeg opus sdl2 sdl2_ttf
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        find . -name "*.moc" -delete
        find . -name "moc_*.cpp" -delete
        find . -name "moc_*.h" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf soundio/Makefile* soundio/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
        rm -rf app/debug app/release
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        export MACOSX_DEPLOYMENT_TARGET=14.0
        
        # Force a complete clean build to ensure MOC files are generated
        make clean || true
        qmake6 artemis.pro CONFIG+=release CONFIG+=sdk_no_version_check QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
        
        # Generate MOC files explicitly and ensure they're created before building
        make -j$(sysctl -n hw.ncpu) qmake_all
        
        # Force generation of specific problematic MOC files first
        cd app
        if [ -f Makefile.Release ]; then
          # Generate MOC headers explicitly
          make -f Makefile.Release compiler_moc_header_make_all || echo "MOC header generation completed"
          # Generate MOC source files explicitly  
          make -f Makefile.Release compiler_moc_source_make_all || echo "MOC source generation completed"
          
          # Verify critical MOC files exist, generate manually if needed
          # Generate into the source folder so #include "*.moc" resolves relative to the .cpp file
          if [ ! -f backend/computermanager.moc ]; then
            echo "Manually generating backend/computermanager.moc"
            "$Qt6_DIR/libexec/moc" backend/computermanager.cpp -o backend/computermanager.moc
          fi
          if [ ! -f backend/boxartmanager.moc ]; then
            echo "Manually generating backend/boxartmanager.moc"
            "$Qt6_DIR/libexec/moc" backend/boxartmanager.cpp -o backend/boxartmanager.moc
          fi
          if [ ! -f gui/computermodel.moc ]; then
            echo "Manually generating gui/computermodel.moc"
            "$Qt6_DIR/libexec/moc" gui/computermodel.cpp -o gui/computermodel.moc
          fi
        fi
        
        # Clean and rebuild all subprojects with consistent deployment target
        cd ..
        make clean || true
        
        # Build each subproject individually with deployment target
        for subdir in moonlight-common-c qmdnsengine h264bitstream soundio; do
          if [ -d "$subdir" ]; then
            echo "Building $subdir with deployment target..."
            cd "$subdir"
            make clean || true
            qmake6 *.pro CONFIG+=release QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
            make -j$(sysctl -n hw.ncpu)
            cd ..
          fi
        done
        
        # Build app sub-project to ensure .moc is picked up correctly
        cd app
        qmake6 app.pro CONFIG+=release QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
        make -j$(sysctl -n hw.ncpu) release
        cd ..
        
        # Final build
        qmake6 artemis.pro CONFIG+=release CONFIG+=sdk_no_version_check QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
        make -j$(sysctl -n hw.ncpu)
    
    - name: Package macOS Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Install create-dmg if not available
        if ! command -v create-dmg &> /dev/null; then
          echo "Installing create-dmg..."
          brew install create-dmg
        fi
        
        # Use the DMG generation script to create universal DMG
        # Ensure version is available for DMG naming
        echo "$VERSION" > app/version.txt
        
        # Run DMG generation with error handling
        DMG_OUTPUT="Artemis-${VERSION}.dmg"
        if ! ./scripts/generate-dmg.sh Release "$VERSION"; then
          echo "DMG generation failed, checking for common issues..."
          
          # Check if create-dmg is available
          create-dmg --help || echo "create-dmg not properly installed"
          
          # List what was actually created
          echo "Contents of build directory:"
          find build -name "*.dmg" -o -name "*.app" -o -name "Artemis*" | head -20
          
          # Try a simpler fallback DMG creation with proper .dmg extension
          echo "Attempting fallback DMG creation..."
          
          if [ -d "build/build-Release" ]; then
            # Use create-dmg directly with correct argument order
            echo "Found Artemis.app at app/Artemis.app"
            mkdir -p build/installer-Release
            # Simple approach using hdiutil which is more reliable
            if [ -d "app/Artemis.app" ]; then
              echo "Creating DMG with hdiutil..."
              hdiutil create -srcfolder app/Artemis.app -volname "Artemis" "build/installer-Release/Artemis-${VERSION}.dmg" || {
                echo "hdiutil failed, trying create-dmg with minimal options..."
                create-dmg \
                  --volname "Artemis" \
                  --no-internet-enable \
                  --app-drop-link 350 185 \
                  "build/installer-Release/Artemis-${VERSION}.dmg" \
                  "app/" || exit 1
              }
            else
              echo "Error: No Artemis.app found in app/ directory"
              exit 1
            fi
            cd build/build-Release
            # Look for the app bundle in the most likely locations
            if [ -d "app/Artemis.app" ]; then
              echo "Found Artemis.app at app/Artemis.app"
              # Create a simple DMG manually with proper filename
              mkdir -p ../installer-Release
              create-dmg --volname "Artemis-$VERSION" \
                --icon-size 80 \
                --icon "app/Artemis.app" 200 190 \
                --hide-extension "app/Artemis.app" \
                --app-drop-link 400 185 \
                "../installer-Release/Artemis-$VERSION.dmg" \
                "app/Artemis.app"
              cd ../..
            elif [ -d "Artemis.app" ]; then
              echo "Found Artemis.app at root level"
              # Create a simple DMG manually with proper filename
              mkdir -p ../installer-Release
              create-dmg --volname "Artemis-$VERSION" \
                --icon-size 80 \
                --icon "Artemis.app" 200 190 \
                --hide-extension "Artemis.app" \
                --app-drop-link 400 185 \
                "../installer-Release/Artemis-$VERSION.dmg" \
                "Artemis.app"
              cd ../..
            else
              echo "ERROR: Artemis.app not found in build/build-Release"
              echo "Available directories in build/build-Release:"
              find . -name "*.app" -type d | head -10
              exit 1
            fi
          else
            echo "ERROR: build/build-Release directory not found"
            exit 1
          fi
        fi
    
    - name: Upload macOS Universal DMG
      uses: actions/upload-artifact@v4
      with:
        name: artemis-macos-universal-${{ needs.setup-version.outputs.version }}
        path: build/installer-Release/Artemis-${{ needs.setup-version.outputs.version }}.dmg
        retention-days: 30

  build-linux-dev:
    name: Linux Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0

    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        qmake6 artemis.pro CONFIG+=release
        make -j$(nproc)
    
    - name: Package Linux Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Create info file with semantic versioning
        cat > build_info.txt << EOF
        Artemis Desktop Development Build
        Version: $VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        EOF
        
        # Package with semantic version
        tar -czf artemis-linux-$VERSION.tar.gz -C app artemis -C .. build_info.txt
    - name: Upload Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-linux-${{ needs.setup-version.outputs.version }}
        path: artemis-linux-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  build-appimage-dev:
    name: AppImage Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev file wget desktop-file-utils \
          libxcb-cursor-dev
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf soundio/Makefile* soundio/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        # Clean any problematic files
        rm -rf AntiHooking/ || true
        rm -rf config.tests/SL/ || true
        rm -f app/test_*.cpp || true
        # Build with proper configuration
        qmake6 artemis.pro CONFIG+=release
        make -j$(nproc)
    
    - name: Verify build output
      run: |
        ls -la app/
        file app/artemis || echo "artemis binary not found"
        ldd app/artemis || echo "ldd failed"
    
    - name: Create AppImage
      env:
          VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Download linuxdeploy and Qt plugin
        wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
        wget -q https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage
        chmod +x linuxdeploy*.AppImage
        
        # Create AppDir structure
        mkdir -p AppDir/usr/bin
        cp app/artemis AppDir/usr/bin/artemis-dev
        
        # Create desktop file
        cat > AppDir/artemis-dev.desktop << 'EOF'
        [Desktop Entry]
        Type=Application
        Name=Artemis Desktop (Dev)
        Comment=Artemis Desktop Development Build
        Exec=artemis-dev
        Icon=artemis-dev
        Categories=Game;Network;
        StartupNotify=true
        EOF
        
        # Create a simple icon placeholder
        mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
        convert -size 256x256 xc:blue -fill white -gravity center -pointsize 24 -annotate +0+0 "Artemis\nDev" AppDir/usr/share/icons/hicolor/256x256/apps/artemis-dev.png 2>/dev/null || {
          echo "Creating placeholder icon"
          touch AppDir/usr/share/icons/hicolor/256x256/apps/artemis-dev.png
        }
        
        # Create build info
        cat > AppDir/build_info.txt << EOF
        Artemis Desktop Development Build (AppImage)
        Version: $VERSION
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date)
        EOF
        
        # Set environment variables for linuxdeploy
        export OUTPUT="artemis-appimage-${VERSION}-x86_64.AppImage"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        export QML_SOURCES_PATH="$Qt6_DIR/qml"

        # Build AppImage
        ./linuxdeploy-x86_64.AppImage \
          --appdir AppDir \
          --executable AppDir/usr/bin/artemis-dev \
          --desktop-file AppDir/artemis-dev.desktop \
          --plugin qt \
          --output appimage
        
        # Verify and rename if necessary
        ls -la *.AppImage || echo "No AppImage files found"
        if [ ! -f "$OUTPUT" ]; then
          APPIMAGE_FILE=$(ls *.AppImage | head -n1)
          if [ -n "$APPIMAGE_FILE" ]; then
            mv "$APPIMAGE_FILE" "$OUTPUT"
            echo "Renamed $APPIMAGE_FILE to $OUTPUT"
          else
            echo "Error: No AppImage file was created"
            exit 1
          fi
        fi
        
        # Final verification
        chmod +x "$OUTPUT"
        ls -la "$OUTPUT"
        file "$OUTPUT"
    
    - name: Upload AppImage Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-appimage-${{ needs.setup-version.outputs.version }}
        path: artemis-appimage-${{ needs.setup-version.outputs.version }}-x86_64.AppImage
        retention-days: 30

  build-flatpak-dev:
    name: Flatpak Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Install Flatpak and dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y flatpak flatpak-builder
        sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
        sudo flatpak install -y flathub org.freedesktop.Platform//23.08 org.freedesktop.Sdk//23.08 org.kde.Platform//6.6 org.kde.Sdk//6.6

    - name: Find available LLVM extensions
      run: flatpak remote-ls flathub | grep org.freedesktop.Sdk.Extension.llvm
    
    - name: Create Flatpak manifest
      run: |
        cat > com.artemisdesktop.ArtemisDesktopDev.yml << 'EOF'
        app-id: com.artemisdesktop.ArtemisDesktopDev
        runtime: org.kde.Platform
        runtime-version: '6.6'
        sdk: org.kde.Sdk
        sdk-extensions:
          - org.freedesktop.Sdk.Extension.llvm17
          - org.freedesktop.Sdk.Extension.rust-stable
        command: artemis-dev
        add-extensions:
          org.freedesktop.Platform.GL.default:
            directory: lib/GL
            version: "23.08"
            subdirectory: lib
            no-autodownload: true
            autodelete: false
            add-ld-path: lib
          org.freedesktop.Platform.GL.Mesa:
            directory: lib/GL
            version: "23.08"
            subdirectory: mesa
            no-autodownload: true
            autodelete: false
            add-ld-path: lib
          org.freedesktop.Platform.VAAPI.Intel:
            directory: lib/dri/intel-vaapi-driver
            version: "23.08"
            subdirectory: lib
            no-autodownload: true
            autodelete: false
        finish-args:
          - --share=ipc
          - --socket=x11
          - --socket=wayland
          - --socket=pulseaudio
          - --share=network
          - --filesystem=home
          # GPU and hardware acceleration access
          - --device=dri
          - --filesystem=/sys/dev/char:ro
          - --filesystem=/sys/devices/pci*:ro
          # GPU driver library access
          - --filesystem=/usr/lib/dri:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/dri:ro
          - --filesystem=/usr/lib64/dri:ro
          - --filesystem=/usr/share/drirc.d:ro
          # NVIDIA driver access
          - --filesystem=/usr/lib/nvidia:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/nvidia:ro
          - --filesystem=/usr/lib64/nvidia:ro
          # Mesa/Intel driver access  
          - --filesystem=/usr/lib/mesa:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/mesa:ro
          # VAAPI/VDPAU libraries
          - --filesystem=/usr/lib/libva:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/libva:ro
          - --filesystem=/usr/lib/vdpau:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/vdpau:ro
        modules:
          - name: opus
            sources:
              - type: archive
                url: https://downloads.xiph.org/releases/opus/opus-1.4.tar.gz
                sha256: c9b32b4253be5ae63d1ff16eea06b94b5f0f2951b7a02aceef58e3a3ce49c51f
          
          - name: sdl2
            sources:
              - type: archive
                url: https://github.com/libsdl-org/SDL/releases/download/release-2.28.5/SDL2-2.28.5.tar.gz
                sha256: 332cb37d0be20cb9541739c61f79bae5a477427d79ae85e352089afdaf6666e4
          
          - name: sdl2-ttf
            sources:
              - type: archive
                url: https://github.com/libsdl-org/SDL_ttf/releases/download/release-2.20.2/SDL2_ttf-2.20.2.tar.gz
                sha256: 9dc71ed93487521b107a2c4a9ca6bf43fb62f6bddd5c26b055e6b91418a22053
          
          - name: artemis-desktop-dev
            buildsystem: simple
            build-commands:
              - rm -f .qmake.stash .qmake.cache
              - find . -name "Makefile*" -delete || true
              - rm -rf AntiHooking/ || true
              - rm -rf config.tests/SL/ || true
              - rm -f app/test_*.cpp || true
              - qmake6 artemis.pro CONFIG+=release
              - make -j$(nproc)
              - install -Dm755 app/artemis /app/bin/artemis-dev
            sources:
              - type: dir
                path: .
            post-install:
              - |
                install -Dm644 /dev/stdin /app/share/applications/com.artemisdesktop.ArtemisDesktopDev.desktop << 'EOD'
                [Desktop Entry]
                Type=Application
                Name=Artemis Desktop (Dev)
                Comment=Artemis Desktop Development Build
                Exec=artemis-dev
                Icon=com.artemisdesktop.ArtemisDesktopDev
                Categories=Game;Network;
                EOD
        EOF
    
    - name: Build Flatpak
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        flatpak-builder --force-clean --repo=repo build-dir com.artemisdesktop.ArtemisDesktopDev.yml
        flatpak build-bundle repo artemis-flatpak-$VERSION.flatpak com.artemisdesktop.ArtemisDesktopDev
    
    - name: Upload Flatpak Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-flatpak-${{ needs.setup-version.outputs.version }}
        path: artemis-flatpak-${{ needs.setup-version.outputs.version }}.flatpak
        retention-days: 30

  build-raspberry-pi-dev:
    name: Raspberry Pi ARM64 Development Build
    needs: setup-version
    runs-on: ubuntu-22.04-arm
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0

    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"

    - name: Install ARM64 dependencies and Qt
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          qt6-base-dev qt6-base-dev-tools qt6-declarative-dev qt6-declarative-dev-tools libqt6svg6-dev \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev libsdl2-ttf-dev \
          libssl-dev libavcodec-dev libavformat-dev libavutil-dev libswscale-dev \
          libva-dev libvdpau-dev libxkbcommon-dev wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev libgles2-mesa-dev libglu1-mesa-dev \
          libibus-1.0-dev libpulse-dev libudev-dev libx11-dev libxcursor-dev libxext-dev \
          libxi-dev libxinerama-dev libxrandr-dev libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev

    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete || true

    - name: Build for Raspberry Pi ARM64
      run: |
        # Simple native ARM64 build - no cross-compilation needed!
        qmake6 artemis.pro CONFIG+=release
        make -j$(nproc)

    - name: Verify ARM64 binary
      run: |
        echo "Verifying ARM64 binary:"
        file app/artemis
        readelf -h app/artemis | grep Machine || true

    - name: Create installation package
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        mkdir -p artemis-package
        cp app/artemis artemis-package/
        
        # Create simple install script
        cat > artemis-package/install.sh << 'EOF'
        #!/bin/bash
        echo "Installing Artemis Desktop for Raspberry Pi..."
        
        # Make binary executable
        chmod +x artemis
        
        # Copy to local bin directory
        mkdir -p ~/.local/bin
        cp artemis ~/.local/bin/
        
        # Create desktop entry
        mkdir -p ~/.local/share/applications
        cat > ~/.local/share/applications/artemis-desktop.desktop << 'EOD'
        [Desktop Entry]
        Type=Application
        Name=Artemis Desktop
        Comment=Game streaming client
        Exec=artemis
        Icon=artemis-desktop
        Categories=Game;Network;
        EOD
        
        echo "Installation complete!"
        echo "You can now run 'artemis' from terminal or find it in applications menu"
        EOF
        
        chmod +x artemis-package/install.sh
        
        # Create build info
        cat > artemis-package/build_info.txt << EOF
        Artemis Desktop Raspberry Pi ARM64 Build
        Version: $SEMANTIC_VERSION
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        Architecture: ARM64 (native build)
        Commit: ${{ github.sha }}
        Branch: ${{ github.ref_name }}
        
        Quick Start:
        1. Extract this archive
        2. Run: ./install.sh
        3. Launch from terminal: artemis
        EOF

        # Create the zip file
        cd artemis-package
        zip -r "../artemis-raspberry-pi-arm64-$SEMANTIC_VERSION.zip" .
        cd ..

    - name: Upload Raspberry Pi Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-raspberry-pi-arm64-${{ needs.setup-version.outputs.version }}
        path: artemis-raspberry-pi-arm64-${{ needs.setup-version.outputs.version }}.zip
        retention-days: 30

  build-steamdeck-dev:
    name: Steam Deck Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install Steam Deck specific dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev
    
    - name: Build for Steam Deck
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        # Build with Steam Deck optimizations
        qmake6 artemis.pro CONFIG+=release CONFIG+=steamdeck
        make -j$(nproc)
    
    - name: Package Steam Deck Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        mkdir -p steamdeck-package
        cp app/artemis steamdeck-package/artemis-dev
        
        # Create Steam Deck specific files
        cat > steamdeck-package/artemis-dev.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=Artemis Desktop (Dev)
        Comment=Artemis Desktop Development Build - Optimized for Steam Deck
        Exec=artemis-dev
        Icon=artemis-dev
        Categories=Game;Network;
        EOF
        
        # Create installation script for Steam Deck
        cat > steamdeck-package/install-steamdeck.sh << 'EOF'
        #!/bin/bash
        echo "Installing Artemis Desktop Development Build for Steam Deck..."
        
        # Create directories
        mkdir -p ~/.local/share/applications
        mkdir -p ~/.local/bin
        
        # Copy files
        cp artemis-dev ~/.local/bin/
        chmod +x ~/.local/bin/artemis-dev
        cp artemis-dev.desktop ~/.local/share/applications/
        
        echo "Installation complete!"
        echo "You can now find Artemis Desktop (Dev) in your applications menu."
        EOF
        
        chmod +x steamdeck-package/install-steamdeck.sh
        
        # Create build info
        cat > steamdeck-package/build_info.txt << EOF
        Artemis Desktop Development Build (Steam Deck)
        Version: $VERSION
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date)
        
        Installation:
        1. Extract this archive
        2. Run: ./install-steamdeck.sh
        3. Find Artemis Desktop (Dev) in your applications
        EOF
        
        # Create README for Steam Deck users
        cat > steamdeck-package/README-SteamDeck.md << EOF
        # Artemis Desktop for Steam Deck (Development Build)
        
        ## Installation
        1. Extract this archive to a folder
        2. Open a terminal in that folder
        3. Run: \`./install-steamdeck.sh\`
        4. The app will be available in your applications menu
        
        ## Steam Deck Specific Notes
        - This build is optimized for Steam Deck's controls and display
        - Use the touchscreen or external mouse/keyboard for initial setup
        - Game mode streaming works best with the built-in controls
        
        ## Troubleshooting
        - If you have issues, try running from terminal: \`~/.local/bin/artemis-dev\`
        - Check the build_info.txt for version details
        EOF
        
        tar -czf artemis-steamdeck-$VERSION.tar.gz -C steamdeck-package .
    
    - name: Upload Steam Deck Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-steamdeck-${{ needs.setup-version.outputs.version }}
        path: artemis-steamdeck-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  create-dev-release:
    name: Create Development Release
    needs: [setup-version, build-windows-x64-portable, build-windows-arm64-portable, build-windows-universal-installer, build-macos-dev, build-linux-dev, build-appimage-dev, build-flatpak-dev, build-raspberry-pi-dev, build-steamdeck-dev]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && needs.setup-version.outputs.should_build == 'true'  # Create releases for develop/main branches when builds ran
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for changelog
    
    - name: Display release version info
      run: |
        echo "Creating release with version: ${{ needs.setup-version.outputs.version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"

    - name: Create tag for release
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag ${{ needs.setup-version.outputs.version }}
        git push origin ${{ needs.setup-version.outputs.version }}

    - name: Generate Changelog
      id: changelog
      run: |
        CURRENT_VERSION="${{ needs.setup-version.outputs.version }}"
        PREV_TAG=$(git tag --sort=-creatordate | grep -v "$CURRENT_VERSION" | head -n1)
        if [ -z "$PREV_TAG" ]; then
          SINCE_DATE=$(date -d '7 days ago' '+%Y-%m-%d')
          echo "No previous release found. Getting commits since $SINCE_DATE"
          COMMITS=$(git log --since="$SINCE_DATE" --pretty=format:"%h|%s|%an|%ad" --date=short --no-merges)
        else
          echo "Getting commits since last release: $PREV_TAG"
          COMMITS=$(git log ${PREV_TAG}..$CURRENT_VERSION --pretty=format:"%h|%s|%an|%ad" --date=short --no-merges)
        fi
        FEATURES=""
        BUGFIXES=""
        IMPROVEMENTS=""
        OTHER=""
        while IFS='|' read -r hash subject author date; do
          if [ -z "$hash" ]; then continue; fi
          subject=$(echo "$subject" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          if echo "$subject" | grep -iE "^(feat|feature|add|implement|new)[:|\s]" > /dev/null; then
            FEATURES="${FEATURES}- ${subject} (${hash})\n"
          elif echo "$subject" | grep -iE "^(fix|bug|resolve|correct)[:|\s]" > /dev/null; then
            BUGFIXES="${BUGFIXES}- ${subject} (${hash})\n"
          elif echo "$subject" | grep -iE "^(improve|enhance|update|optimize|refactor)[:|\s]" > /dev/null; then
            IMPROVEMENTS="${IMPROVEMENTS}- ${subject} (${hash})\n"
          else
            OTHER="${OTHER}- ${subject} (${hash})\n"
          fi
        done <<< "$COMMITS"
        CHANGELOG="##  Development Build Changelog\n\n"
        [ ! -z "$FEATURES" ] && CHANGELOG="${CHANGELOG}###  New Features\n${FEATURES}\n"
        [ ! -z "$BUGFIXES" ] && CHANGELOG="${CHANGELOG}###  Bug Fixes\n${BUGFIXES}\n"
        [ ! -z "$IMPROVEMENTS" ] && CHANGELOG="${CHANGELOG}###  Improvements\n${IMPROVEMENTS}\n"
        [ ! -z "$OTHER" ] && CHANGELOG="${CHANGELOG}###  Other Changes\n${OTHER}\n"
        echo -e "$CHANGELOG" > changelog.md
       
        echo "Generated changelog:"
        cat changelog.md
        {
          echo 'changelog<<EOF'
          cat changelog.md
          echo EOF
        } >> $GITHUB_OUTPUT
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Check if artifacts exist (handle build skipping scenario)
      id: check-artifacts
      run: |
        if [ -d "artifacts" ] && [ "$(ls -A artifacts)" ]; then
          echo "artifacts_exist=true" >> $GITHUB_OUTPUT
          echo "Artifacts found - proceeding with release"
        else
          echo "artifacts_exist=false" >> $GITHUB_OUTPUT
          echo "No artifacts found - builds were skipped"
          echo "Will attempt to find and link to previous build with same commit"
          
          # Try to find a previous release with the same commit hash
          COMMIT_HASH="${{ github.sha }}"
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "Looking for existing artifacts with commit: $COMMIT_HASH"
        fi

    - name: Find and download previous artifacts if builds were skipped
     
      id: find-previous
      if: steps.check-artifacts.outputs.artifacts_exist == 'false'
      run: |
        echo "Searching for previous release with commit ${{ steps.check-artifacts.outputs.commit_hash }}"
        
        # Use GitHub API to find releases
        RELEASES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/releases?per_page=50")
        
        # Look for a release with matching commit (in tag or body)
        MATCHING_RELEASE=$(echo "$RELEASES" | jq -r '.[] | select(.body | contains("${{ steps.check-artifacts.outputs.commit_hash }}")) | .tag_name' | head -n1)
        
        if [ -n "$MATCHING_RELEASE" ] && [ "$MATCHING_RELEASE" != "null" ]; then
          echo "Found matching release: $MATCHING_RELEASE"
          echo "previous_release_tag=$MATCHING_RELEASE" >> $GITHUB_OUTPUT
          
          # Download assets from the matching release
          mkdir -p reused-artifacts
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$MATCHING_RELEASE")
          
          # Download all assets
          echo "$RELEASE_INFO" | jq -r '.assets[].browser_download_url' | while read -r url; do
            if [ -n "$url" ]; then
              filename=$(basename "$url")
              echo "Downloading: $filename"
              curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -o "reused-artifacts/$filename" "$url"
            fi
          done
          
          echo "reused_artifacts_available=true" >> $GITHUB_OUTPUT
          ls -la reused-artifacts/
        else
          echo "No matching release found with commit ${{ steps.check-artifacts.outputs.commit_hash }}"
          echo "reused_artifacts_available=false" >> $GITHUB_OUTPUT
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: List downloaded files for debugging
      if: steps.check-artifacts.outputs.artifacts_exist == 'true'
      run: ls -R artifacts
      
    - name: List reused artifacts for debugging
      if: steps.check-artifacts.outputs.artifacts_exist == 'false'
      run: |
        if [ -d "reused-artifacts" ]; then
          echo "Reused artifacts found:"
          ls -la reused-artifacts/
        else
          echo "No reused artifacts available"
        fi
    
    - name: Create Development Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.setup-version.outputs.version }}
        name: "${{ (github.ref_name == 'main' || github.ref_name == 'master') && ' Production Release' || ' Development Build' }} ${{ needs.setup-version.outputs.version }}"
        body: |
          ${{ (github.ref_name == 'main' || github.ref_name == 'master') && ' **Production Release** 

          This is an official production release of Artemis Desktop.

          ** Stable**: This release has been tested and is recommended for general use.' || ' **Development Build** 
          
          This is an automated development build from the `develop` branch.
          
          ** Warning**: Development builds are unstable and intended for testing purposes only. Use at your own risk!' }}
          
          ---
          
          ${{ steps.changelog.outputs.changelog }}
          
          ---
          
          ##  Build Information
          - **Version**: `${{ needs.setup-version.outputs.version }}`
          - **Numeric Version**: `${{ needs.setup-version.outputs.numeric_version }}`
          - **Branch**: `${{ github.ref_name }}`
          - **Commit**: `${{ github.sha }}`
          - **Build**: #${{ github.run_number }}
          
          ##  Installation
          ${{ (steps.check-artifacts.outputs.artifacts_exist == 'true' || steps.find-previous.outputs.reused_artifacts_available == 'true') && '1. Download the appropriate file for your platform
          2. Extract the archive (if applicable)
          3. Run the executable (may require additional setup on some platforms)' || 'No installation files are available for this release. Please check recent releases or feature branches for builds.' }}
        files: |
          artifacts/**/*.zip
          artifacts/**/*.exe
          artifacts/**/*.dmg
          artifacts/**/*.tar.gz
          artifacts/**/*.AppImage
          artifacts/**/*.flatpak
          artifacts/**/artemis
          artifacts/**/build_info.txt
          artifacts/**/install.sh
        prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        draft: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}