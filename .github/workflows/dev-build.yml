name: Development Build

# This workflow handles development builds with intelligent build skipping:
# - Feature branches: Build artifacts, no releases (testing only)  
# - Develop branch: Build artifacts + create development releases (when meaningful changes are merged)
# - Main/Master branch: ALWAYS build + create production releases (releases require fresh artifacts)
#
# Smart merge detection prevents redundant builds by:
# - Main/Master: Always builds (never skip releases!)
# - Detecting merge commits vs regular commits
# - For merges: Analyzing actual changes being merged (not just the merge commit)
# - For regular commits: Comparing against previous commit
# - Skipping builds when only documentation/config files changed (.md, .txt, .yml, .yaml, .github/)
# - Respecting [skip ci] or [ci skip] in commit messages (except on main/master)
#
# This ensures develop/main branches BUILD when feature branches are merged (as they should!)
# while still preventing redundant builds when no meaningful code changes exist.

on:
  push:
    branches: 
      - develop
      - dev
      - main
      - master
      - 'feature/**'
      - 'feat/**'
      - 'fix/**'
  workflow_dispatch:  # Allow manual triggering

env:
  QT_VERSION: '6.8.3'

jobs:
  setup-version:
    name: Setup Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      numeric_version: ${{ steps.version.outputs.numeric_version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      should_build: ${{ steps.check-changes.outputs.should_build }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for proper versioning
      
      - name: Check for meaningful changes
        id: check-changes
        run: |
          # Always build on main/master branch (releases)
          if [[ "${{ github.ref_name }}" == "main" || "${{ github.ref_name }}" == "master" ]]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Always building on main/master branch for release"
            exit 0
          fi
          
          # Skip builds if commit message contains [skip ci] or [ci skip]
          if echo "${{ github.event.head_commit.message }}" | grep -E "\[(skip ci|ci skip)\]" > /dev/null; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "Build skipped due to [skip ci] in commit message"
            exit 0
          fi
          
          # Check if this is a merge commit (has multiple parents)
          PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
          PARENT_COUNT=$((PARENT_COUNT - 1))  # Subtract 1 because first item is the commit hash itself
          
          if [ "$PARENT_COUNT" -gt 1 ]; then
            echo "Detected merge commit with $PARENT_COUNT parents"
            
            # For merge commits, check the actual changes being merged
            # Compare against the first parent (the target branch before merge)
            FIRST_PARENT=$(git rev-parse HEAD^1)
            echo "Comparing changes against first parent: $FIRST_PARENT"
            
            # Get all changed files in this merge, excluding documentation/config files but allowing workflow changes
            CHANGED_FILES=$(git diff --name-only $FIRST_PARENT HEAD | grep -v -E "(\.md$|test.*\.txt$|README.*\.txt$|CHANGELOG.*\.txt$)" | grep -v -E "(\.yml$|\.yaml$)" | wc -l)
            WORKFLOW_FILES=$(git diff --name-only $FIRST_PARENT HEAD | grep -E "^\.github/workflows/.*\.(yml|yaml)$" | wc -l)
            TOTAL_MEANINGFUL=$((CHANGED_FILES + WORKFLOW_FILES))
            echo "Meaningful files changed in merge: $CHANGED_FILES"
            echo "Workflow files changed: $WORKFLOW_FILES"
            echo "Total meaningful changes: $TOTAL_MEANINGFUL"
            
            if [ "$TOTAL_MEANINGFUL" -eq 0 ]; then
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "Skipping build - merge contains no meaningful code changes"
              exit 0
            else
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "Build will proceed - merge contains $TOTAL_MEANINGFUL meaningful changes (code: $CHANGED_FILES, workflows: $WORKFLOW_FILES)"
              exit 0
            fi
          else
            echo "Regular commit (not a merge) - checking for meaningful changes"
            
            # For regular commits, check against previous commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep -v -E "(\.md$|test.*\.txt$|README.*\.txt$|CHANGELOG.*\.txt$)" | grep -v -E "(\.yml$|\.yaml$)" | wc -l)
            WORKFLOW_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E "^\.github/workflows/.*\.(yml|yaml)$" | wc -l)
            TOTAL_MEANINGFUL=$((CHANGED_FILES + WORKFLOW_FILES))
            echo "Meaningful files changed: $CHANGED_FILES"
            echo "Workflow files changed: $WORKFLOW_FILES" 
            echo "Total meaningful changes: $TOTAL_MEANINGFUL"
            
            if [ "$TOTAL_MEANINGFUL" -eq 0 ]; then
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "Skipping build - no meaningful code changes detected"
              exit 0
            fi
          fi
          
          echo "should_build=true" >> $GITHUB_OUTPUT
          echo "Build will proceed - meaningful changes detected (including code and/or workflow changes)"
      
      - name: Generate semantic version
        id: version
        run: |
          # Base version from app/version.txt
          BASE_VERSION=$(cat app/version.txt | tr -d '\n\r')
          
          # Get branch info
          BRANCH_NAME="${{ github.ref_name }}"
          BRANCH_SANITIZED=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Get commit info
          COMMIT_SHORT="${{ github.sha }}"
          COMMIT_SHORT="${COMMIT_SHORT:0:7}"
          
          # Get timestamp info
          TIMESTAMP=$(date +"%Y%m%d")
          BUILD_NUMBER=$(date +"%H%M")
          
          # Determine if this is a prerelease
          IS_PRERELEASE="true"
          PRERELEASE_SUFFIX=""
          
          if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
            # Main branch = stable release
            VERSION="$BASE_VERSION"
            IS_PRERELEASE="false"
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            # Develop branch = development prerelease
            VERSION="$BASE_VERSION-dev.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="dev"
          elif [[ "$BRANCH_NAME" =~ ^(feature|feat)/ ]]; then
            # Feature branch = feature prerelease
            FEATURE_NAME=$(echo "$BRANCH_NAME" | sed 's|^.*/||' | sed 's/[^a-zA-Z0-9._-]/-/g')
            VERSION="$BASE_VERSION-feature.$FEATURE_NAME.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="feature"
          elif [[ "$BRANCH_NAME" =~ ^(hotfix|fix)/ ]]; then
            # Hotfix branch = hotfix prerelease
            VERSION="$BASE_VERSION-hotfix.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="hotfix"
          else
            # Other branches = alpha prerelease
            VERSION="$BASE_VERSION-alpha.$BRANCH_SANITIZED.$TIMESTAMP.$BUILD_NUMBER+$COMMIT_SHORT"
            PRERELEASE_SUFFIX="alpha"
          fi
          
          # Create numeric version for Windows RC files (extract major.minor.patch + build number)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
          NUMERIC_VERSION="$MAJOR.$MINOR.$PATCH.$BUILD_NUMBER"
          
          # Output all versions
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "numeric_version=$NUMERIC_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          
          echo "Generated versions:"
          echo "  Semantic Version: $VERSION"
          echo "  Numeric Version: $NUMERIC_VERSION"
          echo "  Is Prerelease: $IS_PRERELEASE"
          echo "  Branch: $BRANCH_NAME"
  build-windows-dev:
    name: Windows Development Build
    needs: setup-version
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0  # Needed for version info
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
    
    - name: Install WiX Toolset
      run: |
        # Install .NET SDK first (required for WiX v5)
        choco install dotnet-sdk -y
        
        # Install WiX Toolset v5 as a .NET tool (recommended approach for v5)
        dotnet tool install --global wix --version 5.0.1
        
        # Verify installation
        wix --version
    
    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1
    
    - name: Update version file for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Write numeric version for Windows RC compilation
        echo $env:NUMERIC_VERSION > app\version.txt
        
        # Create detailed version info file for reference  
        @"
        Semantic Version: $env:SEMANTIC_VERSION
        Numeric Version: $env:NUMERIC_VERSION
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        "@ | Out-File -FilePath "build_version_info.txt" -Encoding utf8
    
    - name: Build using build-artemis-arch.bat script
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Add Qt to PATH for the build script
        $env:PATH = "$env:Qt6_DIR\bin;$env:PATH"
        
        # Run our Artemis build script that handles everything
        cmd /c "scripts\build-artemis-arch.bat release"
        
        if ($LASTEXITCODE -ne 0) {
          echo "Build failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
    
    - name: Rename artifacts for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated MSI and portable ZIP files
        $msiFile = Get-ChildItem -Path "build\installer-x64-release" -Filter "*.msi" | Select-Object -First 1
        $zipFile = Get-ChildItem -Path "build\installer-x64-release" -Filter "ArtemisPortable-*.zip" | Select-Object -First 1
        
        if ($msiFile) {
          # Rename MSI installer for Artemis using semantic version
          $newMsiName = "artemis-windows-installer-$env:SEMANTIC_VERSION.msi"
          Move-Item $msiFile.FullName $newMsiName
          echo "Created MSI installer: $newMsiName"
        }
        
        if ($zipFile) {
          # Rename portable ZIP for Artemis using semantic version
          $newZipName = "artemis-windows-portable-$env:SEMANTIC_VERSION.zip"
          Move-Item $zipFile.FullName $newZipName
          echo "Created portable ZIP: $newZipName"
        }
        
        # Create info file with semantic versioning
        @"
        Artemis Desktop Development Build
        Version: $env:SEMANTIC_VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        
        This build includes:
        - MSI Installer with proper dependency handling
        - Portable ZIP package  
        - All required Windows runtime dependencies
        "@ | Out-File -FilePath "build_info.txt" -Encoding utf8
    
    - name: Upload MSI Installer
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-installer-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-installer-${{ needs.setup-version.outputs.version }}.msi
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload Portable ZIP
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-portable-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-portable-${{ needs.setup-version.outputs.version }}.zip
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload Build Info
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-build-info-${{ needs.setup-version.outputs.version }}
        path: build_info.txt
        retention-days: 30

  build-windows-arm64-dev:
    name: Windows ARM64 Development Build
    needs: setup-version
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0  # Needed for version info
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt Desktop (required for ARM64)
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_64'
        modules: 'qtmultimedia'
        
    - name: Setup Qt for ARM64
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}  # Use Qt 6.8.3 LTS which has ARM64 support
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2022_arm64_cross_compiled'  # Correct ARM64 architecture name
        set-env: false  # Don't let this override our Qt6_DIR - we'll set it manually
    
    - name: Install WiX Toolset
      run: |
        # Install .NET SDK first (required for WiX v5)
        choco install dotnet-sdk -y
        
        # Install WiX Toolset v5 as a .NET tool (recommended approach for v5)
        dotnet tool install --global wix --version 5.0.1
        
        # Verify installation
        wix --version
    
    - name: Setup MSVC for ARM64
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: amd64_arm64  # Cross-compile from x64 host to ARM64 target
        
    - name: Verify MSVC ARM64 Setup
      run: |
        echo "MSVC Environment Variables:"
        echo "VSCMD_ARG_TGT_ARCH: $env:VSCMD_ARG_TGT_ARCH"
        echo "VSCMD_ARG_HOST_ARCH: $env:VSCMD_ARG_HOST_ARCH"
        echo "Platform: $env:Platform"
        echo "LIB: $($env:LIB -split ';' | Select-Object -First 3)"
        echo "INCLUDE: $($env:INCLUDE -split ';' | Select-Object -First 3)"
    
    - name: Update version file for development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Write numeric version for Windows RC compilation
        echo $env:NUMERIC_VERSION > app\version.txt
        
        # Create detailed version info file for reference  
        @"
        Semantic Version: $env:SEMANTIC_VERSION
        Numeric Version: $env:NUMERIC_VERSION
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        Architecture: ARM64
        "@ | Out-File -FilePath "build_version_info_arm64.txt" -Encoding utf8
    
    - name: Build using build-artemis-arch.bat script for ARM64
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find and set up Qt ARM64 environment
        echo "Setting up Qt ARM64 environment..."
        $qtArm64Path = "D:\a\artemis\Qt\6.8.3\msvc2022_arm64"
        
        if (-not (Test-Path $qtArm64Path)) {
          echo "ERROR: Qt ARM64 not found at expected path: $qtArm64Path"
          echo "Available Qt installations:"
          Get-ChildItem "D:\a\artemis\Qt\6.8.3" -ErrorAction SilentlyContinue | Select-Object Name
          exit 1
        }
        
        # Set Qt environment
        $env:Qt6_DIR = $qtArm64Path
        $env:PATH = "$qtArm64Path\bin;$env:PATH"
        
        echo "Qt ARM64 setup complete:"
        echo "  Qt6_DIR: $env:Qt6_DIR"
        echo "  qmake available: $(Test-Path "$qtArm64Path\bin\qmake.bat")"
        
        # Verify MSVC ARM64 cross-compilation tools
        echo "Verifying MSVC ARM64 tools..."
        $clPath = where.exe cl.exe 2>$null | Select-String "arm64" | Select-Object -First 1
        $nmakePath = where.exe nmake.exe 2>$null | Select-String "arm64" | Select-Object -First 1
        
        if (-not $clPath) {
          echo "WARNING: ARM64 cl.exe not found in PATH, build script will use explicit paths"
        } else {
          echo "Found ARM64 cl.exe: $clPath"
        }
        
        if (-not $nmakePath) {
          echo "WARNING: ARM64 nmake.exe not found in PATH, build script will use explicit paths"
        } else {
          echo "Found ARM64 nmake.exe: $nmakePath"
        }
        
        # Run the build script
        echo "Running build script for ARM64..."
        cmd /c "scripts\build-artemis-arch.bat release"
        
        $buildExitCode = $LASTEXITCODE
        echo "Build script completed with exit code: $buildExitCode"
        
        if ($buildExitCode -ne 0) {
          echo "ERROR: Build script failed with exit code $buildExitCode"
          
          # Check for nmake.log
          $nmakeLog = Get-ChildItem -Path "build\build-arm64-release" -Filter "nmake.log" -ErrorAction SilentlyContinue
          if ($nmakeLog) {
            echo "=== nmake.log contents ==="
            Get-Content $nmakeLog.FullName
            echo "=== end nmake.log ==="
          }
          
          # Show what was created
          echo "=== Build directory contents ==="
          Get-ChildItem -Path "build" -Recurse -ErrorAction SilentlyContinue | Select-Object FullName
          echo "=== end build directory ==="
          
          exit $buildExitCode
        }
        
        # Verify build output
        echo "Verifying ARM64 build artifacts..."
        $artemisExe = "build\build-arm64-release\app\release\Artemis.exe"
        if (Test-Path $artemisExe) {
          echo "SUCCESS: Artemis.exe found at $artemisExe"
          $fileInfo = Get-Item $artemisExe
          echo "  Size: $($fileInfo.Length) bytes"
          echo "  Created: $($fileInfo.CreationTime)"
        } else {
          echo "ERROR: Artemis.exe not found at expected location: $artemisExe"
          echo "Contents of build\build-arm64-release\app:"
          Get-ChildItem -Path "build\build-arm64-release\app" -Recurse -ErrorAction SilentlyContinue | Select-Object FullName
          exit 1
        }
    
    - name: Rename artifacts for ARM64 development build
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated MSI and portable ZIP files
        $msiFile = Get-ChildItem -Path "build\installer-arm64-release" -Filter "*.msi" | Select-Object -First 1
        $zipFile = Get-ChildItem -Path "build\installer-arm64-release" -Filter "ArtemisPortable-*.zip" | Select-Object -First 1
        
        if ($msiFile) {
          # Rename MSI installer for Artemis ARM64 using semantic version
          $newMsiName = "artemis-windows-arm64-installer-$env:SEMANTIC_VERSION.msi"
          Move-Item $msiFile.FullName $newMsiName
          echo "Created ARM64 MSI installer: $newMsiName"
        }
        
        if ($zipFile) {
          # Rename portable ZIP for Artemis ARM64 using semantic version
          $newZipName = "artemis-windows-arm64-portable-$env:SEMANTIC_VERSION.zip"
          Move-Item $zipFile.FullName $newZipName
          echo "Created ARM64 portable ZIP: $newZipName"
        }
        
        # Create info file with semantic versioning
        @"
        Artemis Desktop Development Build (ARM64)
        Version: $env:SEMANTIC_VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        Architecture: ARM64
        
        This build includes:
        - MSI Installer with proper dependency handling for Windows ARM64
        - Portable ZIP package for Windows ARM64  
        - All required Windows ARM64 runtime dependencies
        "@ | Out-File -FilePath "build_info_arm64.txt" -Encoding utf8
    
    - name: Upload ARM64 MSI Installer
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-arm64-installer-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-arm64-installer-${{ needs.setup-version.outputs.version }}.msi
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload ARM64 Portable ZIP
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-arm64-portable-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-arm64-portable-${{ needs.setup-version.outputs.version }}.zip
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload ARM64 Build Info
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-arm64-build-info-${{ needs.setup-version.outputs.version }}
        path: build_info_arm64.txt
        retention-days: 30

  build-windows-universal-bundle:
    name: Windows Universal Bundle
    needs: [setup-version, build-windows-dev, build-windows-arm64-dev]
    runs-on: windows-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Download Windows x64 artifacts
      uses: actions/download-artifact@v4
      with:
        name: artemis-windows-installer-${{ needs.setup-version.outputs.version }}
        path: ./artifacts-x64/
    
    - name: Download Windows ARM64 artifacts  
      uses: actions/download-artifact@v4
      with:
        name: artemis-windows-arm64-installer-${{ needs.setup-version.outputs.version }}
        path: ./artifacts-arm64/
    
    - name: Setup build environment
      run: |
        # Install .NET SDK first (required for WiX v5)
        choco install dotnet-sdk -y
        
        # Install WiX Toolset v5 as a .NET tool (recommended approach for v5)
        dotnet tool install --global wix --version 5.0.1
        
        # Verify installation
        wix --version
        
        # Also install Visual Studio Build Tools (includes MSBuild) for compatibility
        choco install visualstudio2022buildtools --package-parameters "--includeRecommended --includeOptional --quiet --wait" -y
    
    - name: Prepare individual MSI files
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Create build directory structure
        mkdir -p "build/build-x64-release"
        mkdir -p "build/build-arm64-release"
        
        # Copy individual MSI files to expected locations for bundle generation
        Copy-Item "artifacts-x64/artemis-windows-installer-$env:SEMANTIC_VERSION.msi" "build/build-x64-release/Artemis.msi"
        Copy-Item "artifacts-arm64/artemis-windows-arm64-installer-$env:SEMANTIC_VERSION.msi" "build/build-arm64-release/Artemis.msi"
        
        echo "Prepared MSI files for bundle generation"
        Get-ChildItem -Path "build/" -Recurse | Format-List FullName
    
    - name: Generate Universal Bundle  
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
        NUMERIC_VERSION: ${{ needs.setup-version.outputs.numeric_version }}
      run: |
        # Prefer a purely numeric version for MSBuild/NuGet and WiX
        $msbuildVersion = $env:NUMERIC_VERSION
        if ([string]::IsNullOrWhiteSpace($msbuildVersion)) {
          # Fallback: extract up to 4 numeric segments from semantic version
          $match = [regex]::Match($env:SEMANTIC_VERSION, '\d+(?:\.\d+){2,3}')
          if ($match.Success) { $msbuildVersion = $match.Value } else { $msbuildVersion = '0.0.0.0' }
        }
        
        echo "Original semantic version: $env:SEMANTIC_VERSION"
        echo "MSBuild/WiX version: $msbuildVersion"
        
        # Update version file with MSBuild-compatible version
        echo $msbuildVersion > app\version.txt
        
        # Set environment variables that the WiX scripts expect
        $env:BUILD_CONFIG = "release"
        $env:BUILD_ROOT = $PWD
        
        # Restore and build with explicit version properties for WiX v5
        dotnet restore wix\ArtemisSetup\ArtemisSetup.wixproj
        
        $buildCmd = "dotnet build wix\ArtemisSetup\ArtemisSetup.wixproj --configuration Release --no-restore"
        $buildCmd += " -p:INSTALLER_FOLDER=build\installer-release"
        $buildCmd += " -p:BUILD_FOLDER=build\build-release"
        $buildCmd += " -p:BUILD_ROOT=$env:BUILD_ROOT"
        $buildCmd += " -p:Version=$msbuildVersion -p:WixVersion=$msbuildVersion -p:WixBundleVersion=$msbuildVersion"
        
        Write-Host "Running: $buildCmd"
        cmd /c $buildCmd
        
        if ($LASTEXITCODE -ne 0) {
          echo "Bundle generation failed with exit code $LASTEXITCODE"
          echo "Trying fallback approach with generate-artemis-bundle.bat script..."
          
          # Fallback to original script approach with version override
          cmd /c "scripts\generate-artemis-bundle.bat release $msbuildVersion"
          
          if ($LASTEXITCODE -ne 0) {
            echo "Fallback also failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
        }
    
    - name: Rename universal bundle
      env:
        SEMANTIC_VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Find the generated bundle
        $bundleFile = Get-ChildItem -Path "build\installer-release" -Filter "ArtemisSetup*.exe" | Select-Object -First 1
        
        if ($bundleFile) {
          # Rename universal bundle
          $newBundleName = "artemis-windows-universal-installer-$env:SEMANTIC_VERSION.exe"
          Move-Item $bundleFile.FullName $newBundleName
          echo "Created universal installer: $newBundleName"
        } else {
          echo "ERROR: Universal bundle not found"
          Get-ChildItem -Path "build\installer-release" -Recurse
          exit 1
        }
        
        # Create info file
        @"
        Artemis Desktop Universal Windows Installer
        Version: $env:SEMANTIC_VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        
        This universal installer includes:
        - Automatic architecture detection (x64 vs ARM64)
        - Visual C++ 2022 Redistributable for both architectures
        - Single installer for all Windows platforms
        "@ | Out-File -FilePath "build_info_universal.txt" -Encoding utf8
    
    - name: Upload Universal Installer
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-universal-installer-${{ needs.setup-version.outputs.version }}
        path: artemis-windows-universal-installer-${{ needs.setup-version.outputs.version }}.exe
        retention-days: 30
        if-no-files-found: warn
    
    - name: Upload Universal Build Info
      uses: actions/upload-artifact@v4
      with:
        name: artemis-windows-universal-build-info-${{ needs.setup-version.outputs.version }}
        path: build_info_universal.txt
        retention-days: 30

  build-macos-dev:
    name: macOS Development Build
    needs: setup-version
    runs-on: macos-latest
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"

    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'mac'
        target: 'desktop'
        modules: 'qtmultimedia'
        
    - name: Set macOS deployment target for compatibility
      run: |
        echo "MACOSX_DEPLOYMENT_TARGET=14.0" >> $GITHUB_ENV
        echo "Qt6_DIR=$Qt6_DIR" >> $GITHUB_ENV
    
    - name: Install dependencies
      run: |
        brew install create-dmg ffmpeg opus sdl2 sdl2_ttf
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        find . -name "*.moc" -delete
        find . -name "moc_*.cpp" -delete
        find . -name "moc_*.h" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf soundio/Makefile* soundio/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
        rm -rf app/debug app/release
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        export MACOSX_DEPLOYMENT_TARGET=14.0
        
        # Force a complete clean build to ensure MOC files are generated
        make clean || true
        qmake6 artemis.pro CONFIG+=release CONFIG+=sdk_no_version_check QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
        
        # Generate MOC files explicitly and ensure they're created before building
        make -j$(sysctl -n hw.ncpu) qmake_all
        
        # Force generation of specific problematic MOC files first
        cd app
        if [ -f Makefile.Release ]; then
          # Generate MOC headers explicitly
          make -f Makefile.Release compiler_moc_header_make_all || echo "MOC header generation completed"
          # Generate MOC source files explicitly  
          make -f Makefile.Release compiler_moc_source_make_all || echo "MOC source generation completed"
          
          # Verify critical MOC files exist, generate manually if needed
          # Generate into the source folder so #include "*.moc" resolves relative to the .cpp file
          if [ ! -f backend/computermanager.moc ]; then
            echo "Manually generating backend/computermanager.moc"
            "$Qt6_DIR/libexec/moc" backend/computermanager.cpp -o backend/computermanager.moc
          fi
          if [ ! -f backend/boxartmanager.moc ]; then
            echo "Manually generating backend/boxartmanager.moc"
            "$Qt6_DIR/libexec/moc" backend/boxartmanager.cpp -o backend/boxartmanager.moc
          fi
          if [ ! -f gui/computermodel.moc ]; then
            echo "Manually generating gui/computermodel.moc"
            "$Qt6_DIR/libexec/moc" gui/computermodel.cpp -o gui/computermodel.moc
          fi
        fi
        
        # Clean and rebuild all subprojects with consistent deployment target
        cd ..
        make clean || true
        
        # Build each subproject individually with deployment target
        for subdir in moonlight-common-c qmdnsengine h264bitstream soundio; do
          if [ -d "$subdir" ]; then
            echo "Building $subdir with deployment target..."
            cd "$subdir"
            make clean || true
            qmake6 *.pro CONFIG+=release QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
            make -j$(sysctl -n hw.ncpu)
            cd ..
          fi
        done
        
        # Build app sub-project to ensure .moc is picked up correctly
        cd app
        qmake6 app.pro CONFIG+=release QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
        make -j$(sysctl -n hw.ncpu) release
        cd ..
        
        # Final build
        qmake6 artemis.pro CONFIG+=release CONFIG+=sdk_no_version_check QMAKE_MACOSX_DEPLOYMENT_TARGET=14.0
        make -j$(sysctl -n hw.ncpu)
    
    - name: Package macOS Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Install create-dmg if not available
        if ! command -v create-dmg &> /dev/null; then
          echo "Installing create-dmg..."
          brew install create-dmg
        fi
        
        # Use the DMG generation script to create universal DMG
        # Ensure version is available for DMG naming
        echo "$VERSION" > app/version.txt
        
        # Run DMG generation with error handling
        DMG_OUTPUT="Artemis-${VERSION}.dmg"
        if ! ./scripts/generate-dmg.sh Release "$VERSION"; then
          echo "DMG generation failed, checking for common issues..."
          
          # Check if create-dmg is available
          create-dmg --help || echo "create-dmg not properly installed"
          
          # List what was actually created
          echo "Contents of build directory:"
          find build -name "*.dmg" -o -name "*.app" -o -name "Artemis*" | head -20
          
          # Try a simpler fallback DMG creation with proper .dmg extension
          echo "Attempting fallback DMG creation..."
          
          if [ -d "build/build-Release" ]; then
            # Use create-dmg directly with correct argument order
            echo "Found Artemis.app at app/Artemis.app"
            mkdir -p build/installer-Release
            create-dmg \
              --volname "Artemis" \
              --window-pos 200 120 \
              --window-size 600 300 \
              --icon-size 100 \
              --icon "Artemis.app" 175 120 \
              --app-drop-link 425 120 \
              "build/installer-Release/Artemis-${VERSION}.dmg" \
              "app/" || {
              echo "Direct create-dmg failed, trying minimal approach..."
              # Even simpler approach - just copy the app and create basic DMG
              if [ -d "app/Artemis.app" ]; then
                hdiutil create -srcfolder app/Artemis.app -volname "Artemis" "build/installer-Release/Artemis-${VERSION}.dmg" || exit 1
              else
                echo "Error: No Artemis.app found in app/ directory"
                exit 1
              fi
            }
            cd build/build-Release
            # Look for the app bundle in the most likely locations
            if [ -d "app/Artemis.app" ]; then
              echo "Found Artemis.app at app/Artemis.app"
              # Create a simple DMG manually with proper filename
              mkdir -p ../installer-Release
              create-dmg --volname "Artemis-$VERSION" \
                --icon-size 80 \
                --icon "app/Artemis.app" 200 190 \
                --hide-extension "app/Artemis.app" \
                --app-drop-link 400 185 \
                "../installer-Release/Artemis-$VERSION.dmg" \
                "app/Artemis.app"
              cd ../..
            elif [ -d "Artemis.app" ]; then
              echo "Found Artemis.app at root level"
              # Create a simple DMG manually with proper filename
              mkdir -p ../installer-Release
              create-dmg --volname "Artemis-$VERSION" \
                --icon-size 80 \
                --icon "Artemis.app" 200 190 \
                --hide-extension "Artemis.app" \
                --app-drop-link 400 185 \
                "../installer-Release/Artemis-$VERSION.dmg" \
                "Artemis.app"
              cd ../..
            else
              echo "ERROR: Artemis.app not found in build/build-Release"
              echo "Available directories in build/build-Release:"
              find . -name "*.app" -type d | head -10
              exit 1
            fi
          else
            echo "ERROR: build/build-Release directory not found"
            exit 1
          fi
        fi
    
    - name: Upload Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-macos-universal-${{ needs.setup-version.outputs.version }}
        path: build/installer-Release/Artemis-${{ needs.setup-version.outputs.version }}.dmg
        retention-days: 30
        
    - name: Upload macOS Build Info
      uses: actions/upload-artifact@v4
      with:
        name: artemis-macos-build-info-${{ needs.setup-version.outputs.version }}
        path: build/installer-Release/build_info_macos.txt
        retention-days: 30
        
    - name: Upload macOS Debug Symbols
      uses: actions/upload-artifact@v4
      with:
        name: artemis-macos-debug-symbols-${{ needs.setup-version.outputs.version }}
        path: build/installer-Release/Artemis-${{ needs.setup-version.outputs.version }}.dsym
        retention-days: 30

  build-linux-dev:
    name: Linux Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0

    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        qmake6 artemis.pro CONFIG+=release
        make -j$(nproc)
    
    - name: Package Linux Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Create info file with semantic versioning
        cat > build_info.txt << EOF
        Artemis Desktop Development Build
        Version: $VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        EOF
        
        # Package with semantic version
        tar -czf artemis-linux-$VERSION.tar.gz -C app artemis -C .. build_info.txt
    - name: Upload Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-linux-${{ needs.setup-version.outputs.version }}
        path: artemis-linux-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  build-appimage-dev:
    name: AppImage Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev file wget desktop-file-utils \
          libxcb-cursor-dev
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf soundio/Makefile* soundio/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash
    
    - name: Build
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        # Clean any problematic files
        rm -rf AntiHooking/ || true
        rm -rf config.tests/SL/ || true
        rm -f app/test_*.cpp || true
        # Build with proper configuration
        qmake6 artemis.pro CONFIG+=release
        make -j$(nproc)
    
    - name: Verify build output
      run: |
        ls -la app/
        file app/artemis || echo "artemis binary not found"
        ldd app/artemis || echo "ldd failed"
    
    - name: Create AppImage
      env:
          VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Download linuxdeploy and Qt plugin
        wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
        wget -q https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage
        chmod +x linuxdeploy*.AppImage
        
        # Create AppDir structure
        mkdir -p AppDir/usr/bin
        cp app/artemis AppDir/usr/bin/artemis-dev
        
        # Create desktop file
        cat > AppDir/artemis-dev.desktop << 'EOF'
        [Desktop Entry]
        Type=Application
        Name=Artemis Desktop (Dev)
        Comment=Artemis Desktop Development Build
        Exec=artemis-dev
        Icon=artemis-dev
        Categories=Game;Network;
        StartupNotify=true
        EOF
        
        # Create a simple icon placeholder
        mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
        convert -size 256x256 xc:blue -fill white -gravity center -pointsize 24 -annotate +0+0 "Artemis\nDev" AppDir/usr/share/icons/hicolor/256x256/apps/artemis-dev.png 2>/dev/null || {
          echo "Creating placeholder icon"
          touch AppDir/usr/share/icons/hicolor/256x256/apps/artemis-dev.png
        }
        
        # Create build info
        cat > AppDir/build_info.txt << EOF
        Artemis Desktop Development Build (AppImage)
        Version: $VERSION
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date)
        EOF
        
        # Set environment variables for linuxdeploy
        export OUTPUT="artemis-appimage-${VERSION}-x86_64.AppImage"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        export QML_SOURCES_PATH="$Qt6_DIR/qml"

        # Build AppImage
        ./linuxdeploy-x86_64.AppImage \
          --appdir AppDir \
          --executable AppDir/usr/bin/artemis-dev \
          --desktop-file AppDir/artemis-dev.desktop \
          --plugin qt \
          --output appimage
        
        # Verify and rename if necessary
        ls -la *.AppImage || echo "No AppImage files found"
        if [ ! -f "$OUTPUT" ]; then
          APPIMAGE_FILE=$(ls *.AppImage | head -n1)
          if [ -n "$APPIMAGE_FILE" ]; then
            mv "$APPIMAGE_FILE" "$OUTPUT"
            echo "Renamed $APPIMAGE_FILE to $OUTPUT"
          else
            echo "Error: No AppImage file was created"
            exit 1
          fi
        fi
        
        # Final verification
        chmod +x "$OUTPUT"
        ls -la "$OUTPUT"
        file "$OUTPUT"
    
    - name: Upload AppImage Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-appimage-${{ needs.setup-version.outputs.version }}
        path: artemis-appimage-${{ needs.setup-version.outputs.version }}-x86_64.AppImage
        retention-days: 30

  build-flatpak-dev:
    name: Flatpak Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Install Flatpak and dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y flatpak flatpak-builder
        sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
        sudo flatpak install -y flathub org.freedesktop.Platform//23.08 org.freedesktop.Sdk//23.08 org.kde.Platform//6.6 org.kde.Sdk//6.6
    
    - name: Create Flatpak manifest
      run: |
        cat > com.artemisdesktop.ArtemisDesktopDev.yml << 'EOF'
        app-id: com.artemisdesktop.ArtemisDesktopDev
        runtime: org.kde.Platform
        runtime-version: '6.6'
        sdk: org.kde.Sdk
        command: artemis-dev
        add-extensions:
          org.freedesktop.Platform.GL.default:
            directory: lib/GL
            version: "23.08"
            subdirectory: lib
            no-autodownload: true
            autodelete: false
            add-ld-path: lib
          org.freedesktop.Platform.VAAPI.Intel:
            directory: lib/dri/intel-vaapi-driver
            version: "23.08"
            subdirectory: lib
            no-autodownload: true
            autodelete: false
        finish-args:
          - --share=ipc
          - --socket=x11
          - --socket=wayland
          - --socket=pulseaudio
          - --share=network
          - --filesystem=home
          # GPU and hardware acceleration access
          - --device=dri
          - --filesystem=/sys/dev/char:ro
          - --filesystem=/sys/devices/pci*:ro
          # GPU driver library access
          - --filesystem=/usr/lib/dri:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/dri:ro
          - --filesystem=/usr/lib64/dri:ro
          - --filesystem=/usr/share/drirc.d:ro
          # NVIDIA driver access
          - --filesystem=/usr/lib/nvidia:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/nvidia:ro
          - --filesystem=/usr/lib64/nvidia:ro
          # Mesa/Intel driver access  
          - --filesystem=/usr/lib/mesa:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/mesa:ro
          # VAAPI/VDPAU libraries
          - --filesystem=/usr/lib/libva:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/libva:ro
          - --filesystem=/usr/lib/vdpau:ro
          - --filesystem=/usr/lib/x86_64-linux-gnu/vdpau:ro
        modules:
          - name: opus
            sources:
              - type: archive
                url: https://downloads.xiph.org/releases/opus/opus-1.4.tar.gz
                sha256: c9b32b4253be5ae63d1ff16eea06b94b5f0f2951b7a02aceef58e3a3ce49c51f
          
          - name: sdl2
            sources:
              - type: archive
                url: https://github.com/libsdl-org/SDL/releases/download/release-2.28.5/SDL2-2.28.5.tar.gz
                sha256: 332cb37d0be20cb9541739c61f79bae5a477427d79ae85e352089afdaf6666e4
          
          - name: sdl2-ttf
            sources:
              - type: archive
                url: https://github.com/libsdl-org/SDL_ttf/releases/download/release-2.20.2/SDL2_ttf-2.20.2.tar.gz
                sha256: 9dc71ed93487521b107a2c4a9ca6bf43fb62f6bddd5c26b055e6b91418a22053
          
          - name: artemis-desktop-dev
            buildsystem: simple
            build-commands:
              - rm -f .qmake.stash .qmake.cache
              - find . -name "Makefile*" -delete || true
              - rm -rf AntiHooking/ || true
              - rm -rf config.tests/SL/ || true
              - rm -f app/test_*.cpp || true
              - qmake6 artemis.pro CONFIG+=release
              - make -j$(nproc)
              - install -Dm755 app/artemis /app/bin/artemis-dev
            sources:
              - type: dir
                path: .
            post-install:
              - |
                install -Dm644 /dev/stdin /app/share/applications/com.artemisdesktop.ArtemisDesktopDev.desktop << 'EOD'
                [Desktop Entry]
                Type=Application
                Name=Artemis Desktop (Dev)
                Comment=Artemis Desktop Development Build
                Exec=artemis-dev
                Icon=com.artemisdesktop.ArtemisDesktopDev
                Categories=Game;Network;
                EOD
        EOF
    
    - name: Build Flatpak
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        flatpak-builder --force-clean --repo=repo build-dir com.artemisdesktop.ArtemisDesktopDev.yml
        flatpak build-bundle repo artemis-flatpak-$VERSION.flatpak com.artemisdesktop.ArtemisDesktopDev
    
    - name: Upload Flatpak Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-flatpak-${{ needs.setup-version.outputs.version }}
        path: artemis-flatpak-${{ needs.setup-version.outputs.version }}.flatpak
        retention-days: 30

  build-raspberry-pi-dev:
    name: Raspberry Pi ARM64 Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0

    - name: Display version info
      run: |
        echo "Using semantic version: ${{ needs.setup-version.outputs.version }}"
        echo "Using numeric version: ${{ needs.setup-version.outputs.numeric_version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"
    
    - name: Setup ARM64 cross-compilation environment
      run: |
        sudo apt-get update
        
        # Enable ARM64 (aarch64) multiarch to allow installing :arm64 packages
        sudo dpkg --add-architecture arm64
        
        # Replace default sources to use ports.ubuntu.com for arm64 to avoid 404s
        sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup
        sudo tee /etc/apt/sources.list >/dev/null << 'EOF'
        # Default amd64 sources
        deb [arch=amd64] http://azure.archive.ubuntu.com/ubuntu/ jammy main restricted universe multiverse
        deb [arch=amd64] http://azure.archive.ubuntu.com/ubuntu/ jammy-updates main restricted universe multiverse
        deb [arch=amd64] http://azure.archive.ubuntu.com/ubuntu/ jammy-backports main restricted universe multiverse
        deb [arch=amd64] http://azure.archive.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse
        
        # ARM64 sources from ports.ubuntu.com
        deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ jammy main restricted universe multiverse
        deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ jammy-updates main restricted universe multiverse
        deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ jammy-backports main restricted universe multiverse  
        deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ jammy-security main restricted universe multiverse
        EOF
        
        sudo apt-get update
        
        # Install cross-compilation toolchain and pkg-config
        sudo apt-get install -y \
          gcc-aarch64-linux-gnu \
          g++-aarch64-linux-gnu \
          libc6-dev-arm64-cross \
          pkg-config
        
        echo "ARM64 cross-compilation toolchain installed successfully"
        echo "Note: Using arm64 ports.ubuntu.com sources to resolve 404s"
    
    - name: Setup Qt for ARM64 cross-compilation
      run: |
        # First, try to update package lists
        sudo apt-get update
        
        # Install Qt6 host tools (needed for qmake6, moc, etc.)
        # We need the host Qt6 for build tools, but will use ARM64 system packages for libraries
        sudo apt-get install -y \
          qt6-base-dev \
          qt6-tools-dev \
          qt6-tools-dev-tools \
          qmake6 \
          libqt6svg6-dev \
          libqt6core6 \
          libqt6gui6 \
          libqt6widgets6 \
          libqt6svg6 || {
            echo "Failed to install some Qt6 packages, trying alternative approach..."
            
            # Fallback: install what's available
            sudo apt-get install -y \
              qt6-base-dev \
              qt6-tools-dev \
              libqt6svg6-dev \
              qmake6 || echo "Using system Qt6 installation"
        }
          
        # Verify Qt6 tools are available
        which qmake6 || echo "qmake6 not found in PATH"
        qmake6 -version || echo "qmake6 version check failed"
        # Use the host Qt installation for cross-compilation
        # This is a minimal approach for ARM64 cross-compilation
        sudo apt-get install -y \
          qt6-base-dev \
          qt6-multimedia-dev \
          qt6-declarative-dev \
          qmake6 \
          qt6-tools-dev
        
        echo "Qt setup complete for ARM64 cross-compilation"
    
    - name: Clean any existing build
      run: |
        rm -f .qmake.stash .qmake.cache
        find . -name "Makefile*" -delete
        rm -rf moonlight-common-c/Makefile* moonlight-common-c/.qmake.stash
        rm -rf qmdnsengine/Makefile* qmdnsengine/.qmake.stash 
        rm -rf h264bitstream/Makefile* h264bitstream/.qmake.stash
        rm -rf soundio/Makefile* soundio/.qmake.stash
        rm -rf app/Makefile* app/.qmake.stash

    - name: Cross-compile for Raspberry Pi ARM64
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
        PKG_CONFIG_PATH: /usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig
        PKG_CONFIG_LIBDIR: /usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig
        PKG_CONFIG_SYSROOT_DIR: /
        CC: aarch64-linux-gnu-gcc
        CXX: aarch64-linux-gnu-g++
        AR: aarch64-linux-gnu-ar
        STRIP: aarch64-linux-gnu-strip
      run: |
        # Install additional ARM64 dev dependencies now that arm64 arch is enabled
        sudo apt-get update
        sudo apt-get install -y \
          libssl-dev:arm64 \
          libavcodec-dev:arm64 \
          libavformat-dev:arm64 \
          libswscale-dev:arm64 \
          libsdl2-dev:arm64 \
          libsdl2-ttf-dev:arm64 \
          libqt6svg6-dev:arm64 \
          libopus-dev:arm64 || echo "Some ARM64 packages not available, will use minimal build"
        # Note: qt6-svg-dev:arm64 is not a valid package; only libqt6svg6-dev:arm64 is needed for SVG support
        
        # Configure for ARM64 cross-compilation with minimal dependencies
        # Disable PKGCONFIG for OpenSSL as fallback if arm64 packages unavailable
        # Also ensure SDL2_ttf can be found via pkg-config
        export PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig:$PKG_CONFIG_PATH"
        export SDL2_CONFIG="$(which sdl2-config || echo '/usr/bin/sdl2-config')"
        
        # Test SDL2_ttf availability
        if pkg-config --exists SDL2_ttf; then
          echo "SDL2_ttf found via pkg-config"
          SDL2_TTF_CFLAGS=$(pkg-config --cflags SDL2_ttf)
          SDL2_TTF_LIBS=$(pkg-config --libs SDL2_ttf)
          echo "SDL2_ttf CFLAGS: $SDL2_TTF_CFLAGS"
          echo "SDL2_ttf LIBS: $SDL2_TTF_LIBS"
        else
          echo "WARNING: SDL2_ttf not found via pkg-config, using fallback paths"
          SDL2_TTF_CFLAGS="-I/usr/include/aarch64-linux-gnu/SDL2 -I/usr/include/SDL2"
          SDL2_TTF_LIBS="-lSDL2_ttf"
        fi
        # Force exclusive use of ARM64 Qt libraries by removing x86_64 paths
        export QT_SELECT=qt6
        export PKG_CONFIG_LIBDIR=/usr/lib/aarch64-linux-gnu/pkgconfig
        export PKG_CONFIG_SYSROOT_DIR=/
        
        # Remove any x86_64 library directories from the system to prevent accidental linking
        sudo mv /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu.backup || true
        
        qmake6 artemis.pro \
          CONFIG+=release \
          CONFIG+=cross_compile \
          CONFIG+=minimal_build \
          QMAKE_CC=aarch64-linux-gnu-gcc \
          QMAKE_CXX=aarch64-linux-gnu-g++ \
          'QMAKE_AR=aarch64-linux-gnu-ar cqs' \
          QMAKE_STRIP=aarch64-linux-gnu-strip \
          QMAKE_LINK=aarch64-linux-gnu-g++ \
          'QMAKE_CXXFLAGS+=-I/usr/include/aarch64-linux-gnu -I/usr/include/aarch64-linux-gnu/openssl -I/usr/include/aarch64-linux-gnu/SDL2' \
          'QMAKE_LFLAGS+=-L/usr/lib/aarch64-linux-gnu -Wl,-rpath,/usr/lib/aarch64-linux-gnu' \
          'QMAKE_LIBDIR=/usr/lib/aarch64-linux-gnu' \
          'LIBS+=-L/usr/lib/aarch64-linux-gnu -lQt6Core -lQt6Gui -lQt6Widgets -lQt6Qml -lQt6Quick -lQt6QuickControls2 -lQt6Svg -lQt6Network -lQt6OpenGL' \
          'CONFIG+=no-pkg-config-openssl' || {
            echo "Main build failed, trying fallback without OpenSSL PKGCONFIG..."
            qmake6 artemis.pro \
              CONFIG+=release \
              CONFIG+=cross_compile \
              CONFIG+=minimal_build \
              CONFIG+=no-openssl \
              QMAKE_CC=aarch64-linux-gnu-gcc \
              QMAKE_CXX=aarch64-linux-gnu-g++ \
              'QMAKE_AR=aarch64-linux-gnu-ar cqs' \
              QMAKE_STRIP=aarch64-linux-gnu-strip \
              QMAKE_LINK=aarch64-linux-gnu-g++ \
              'QMAKE_LIBDIR=/usr/lib/aarch64-linux-gnu' \
              'LIBS+=-L/usr/lib/aarch64-linux-gnu -lQt6Core -lQt6Gui -lQt6Widgets -lQt6Qml -lQt6Quick -lQt6QuickControls2 -lQt6Svg -lQt6Network -lQt6OpenGL'
          }
        # If libssl-dev:arm64 is missing, fallback to minimal build without OpenSSL
        
        # Restore x86_64 libraries after build
        sudo mv /usr/lib/x86_64-linux-gnu.backup /usr/lib/x86_64-linux-gnu || true
        
        # Build for ARM64
        make -j$(nproc)
    
    - name: Package Raspberry Pi Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        # Verify the binary architecture
        file app/artemis
        
        # Create info file
        cat > build_info_rpi.txt << EOF
        Artemis Desktop Raspberry Pi ARM64 Development Build
        Version: $VERSION
        Numeric Version: ${{ needs.setup-version.outputs.numeric_version }}
        Is Prerelease: ${{ needs.setup-version.outputs.is_prerelease }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        Target: Raspberry Pi 4/5 (ARM64)
        
        Installation Notes:
        - Designed for Raspberry Pi 4 or 5 running 64-bit Raspberry Pi OS
        - May also work on other ARM64 Linux systems
        - Requires system libraries for multimedia and graphics
        - Install with: sudo apt install libavcodec58 libavformat58 libsdl2-2.0-0 libqt6core6
        
        Performance Notes:
        - Hardware video decoding supported on compatible systems
        - Optimized for ARM64 architecture
        - May require GPU memory split adjustment for best performance
        EOF
        
        # Package with semantic version
        tar -czf artemis-raspberry-pi-arm64-$VERSION.tar.gz -C app artemis -C .. build_info_rpi.txt
    
    - name: Upload Raspberry Pi Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-raspberry-pi-arm64-${{ needs.setup-version.outputs.version }}
        path: artemis-raspberry-pi-arm64-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  build-steamdeck-dev:
    name: Steam Deck Development Build
    needs: setup-version
    runs-on: ubuntu-22.04
    if: needs.setup-version.outputs.should_build == 'true'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Display version info
      run: echo "Using development version ${{ needs.setup-version.outputs.version }}"
    
    - name: Setup Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        host: 'linux'
        target: 'desktop'
        modules: 'qtmultimedia'
    
    - name: Install Steam Deck specific dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libegl1-mesa-dev libgl1-mesa-dev libopus-dev libsdl2-dev \
          libsdl2-ttf-dev libssl-dev libavcodec-dev libavformat-dev \
          libswscale-dev libva-dev libvdpau-dev libxkbcommon-dev \
          wayland-protocols libdrm-dev nasm libgbm-dev \
          libfreetype6-dev libasound2-dev libdbus-1-dev \
          libgles2-mesa-dev libglu1-mesa-dev libibus-1.0-dev \
          libpulse-dev libudev-dev libx11-dev libxcursor-dev \
          libxext-dev libxi-dev libxinerama-dev libxrandr-dev \
          libxss-dev libxt-dev libxv-dev libxxf86vm-dev \
          libxcb-dri3-dev libx11-xcb-dev
    
    - name: Build for Steam Deck
      run: |
        export PATH="$Qt6_DIR/bin:$PATH"
        export QMAKE="$Qt6_DIR/bin/qmake6"
        # Build with Steam Deck optimizations
        qmake6 artemis.pro CONFIG+=release CONFIG+=steamdeck
        make -j$(nproc)
    
    - name: Package Steam Deck Development Build
      env:
        VERSION: ${{ needs.setup-version.outputs.version }}
      run: |
        mkdir -p steamdeck-package
        cp app/artemis steamdeck-package/artemis-dev
        
        # Create Steam Deck specific files
        cat > steamdeck-package/artemis-dev.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=Artemis Desktop (Dev)
        Comment=Artemis Desktop Development Build - Optimized for Steam Deck
        Exec=artemis-dev
        Icon=artemis-dev
        Categories=Game;Network;
        EOF
        
        # Create installation script for Steam Deck
        cat > steamdeck-package/install-steamdeck.sh << 'EOF'
        #!/bin/bash
        echo "Installing Artemis Desktop Development Build for Steam Deck..."
        
        # Create directories
        mkdir -p ~/.local/share/applications
        mkdir -p ~/.local/bin
        
        # Copy files
        cp artemis-dev ~/.local/bin/
        chmod +x ~/.local/bin/artemis-dev
        cp artemis-dev.desktop ~/.local/share/applications/
        
        echo "Installation complete!"
        echo "You can now find Artemis Desktop (Dev) in your applications menu."
        EOF
        
        chmod +x steamdeck-package/install-steamdeck.sh
        
        # Create build info
        cat > steamdeck-package/build_info.txt << EOF
        Artemis Desktop Development Build (Steam Deck)
        Version: $VERSION
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Built: $(date)
        
        Installation:
        1. Extract this archive
        2. Run: ./install-steamdeck.sh
        3. Find Artemis Desktop (Dev) in your applications
        EOF
        
        # Create README for Steam Deck users
        cat > steamdeck-package/README-SteamDeck.md << EOF
        # Artemis Desktop for Steam Deck (Development Build)
        
        ## Installation
        1. Extract this archive to a folder
        2. Open a terminal in that folder
        3. Run: \`./install-steamdeck.sh\`
        4. The app will be available in your applications menu
        
        ## Steam Deck Specific Notes
        - This build is optimized for Steam Deck's controls and display
        - Use the touchscreen or external mouse/keyboard for initial setup
        - Game mode streaming works best with the built-in controls
        
        ## Troubleshooting
        - If you have issues, try running from terminal: \`~/.local/bin/artemis-dev\`
        - Check the build_info.txt for version details
        EOF
        
        tar -czf artemis-steamdeck-$VERSION.tar.gz -C steamdeck-package .
    
    - name: Upload Steam Deck Development Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: artemis-steamdeck-${{ needs.setup-version.outputs.version }}
        path: artemis-steamdeck-${{ needs.setup-version.outputs.version }}.tar.gz
        retention-days: 30

  create-dev-release:
    name: Create Development Release
    needs: [setup-version, build-windows-dev, build-windows-arm64-dev, build-windows-universal-bundle, build-macos-dev, build-linux-dev, build-appimage-dev, build-flatpak-dev, build-raspberry-pi-dev, build-steamdeck-dev]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && needs.setup-version.outputs.should_build == 'true'  # Create releases for develop/main branches when builds ran
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for changelog
    
    - name: Display release version info
      run: |
        echo "Creating release with version: ${{ needs.setup-version.outputs.version }}"
        echo "Is prerelease: ${{ needs.setup-version.outputs.is_prerelease }}"

    - name: Create tag for release
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag ${{ needs.setup-version.outputs.version }}
        git push origin ${{ needs.setup-version.outputs.version }}

    - name: Generate Changelog
      id: changelog
      run: |
        CURRENT_VERSION="${{ needs.setup-version.outputs.version }}"
        PREV_TAG=$(git tag --sort=-creatordate | grep -v "$CURRENT_VERSION" | head -n1)
        if [ -z "$PREV_TAG" ]; then
          SINCE_DATE=$(date -d '7 days ago' '+%Y-%m-%d')
          echo "No previous release found. Getting commits since $SINCE_DATE"
          COMMITS=$(git log --since="$SINCE_DATE" --pretty=format:"%h|%s|%an|%ad" --date=short --no-merges)
        else
          echo "Getting commits since last release: $PREV_TAG"
          COMMITS=$(git log ${PREV_TAG}..$CURRENT_VERSION --pretty=format:"%h|%s|%an|%ad" --date=short --no-merges)
        fi
        FEATURES=""
        BUGFIXES=""
        IMPROVEMENTS=""
        OTHER=""
        while IFS='|' read -r hash subject author date; do
          if [ -z "$hash" ]; then continue; fi
          subject=$(echo "$subject" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          if echo "$subject" | grep -iE "^(feat|feature|add|implement|new)[:|\s]" > /dev/null; then
            FEATURES="${FEATURES}- ${subject} (${hash})\n"
          elif echo "$subject" | grep -iE "^(fix|bug|resolve|correct)[:|\s]" > /dev/null; then
            BUGFIXES="${BUGFIXES}- ${subject} (${hash})\n"
          elif echo "$subject" | grep -iE "^(improve|enhance|update|optimize|refactor)[:|\s]" > /dev/null; then
            IMPROVEMENTS="${IMPROVEMENTS}- ${subject} (${hash})\n"
          else
            OTHER="${OTHER}- ${subject} (${hash})\n"
          fi
        done <<< "$COMMITS"
        CHANGELOG="##  Development Build Changelog\n\n"
        [ ! -z "$FEATURES" ] && CHANGELOG="${CHANGELOG}###  New Features\n${FEATURES}\n"
        [ ! -z "$BUGFIXES" ] && CHANGELOG="${CHANGELOG}###  Bug Fixes\n${BUGFIXES}\n"
        [ ! -z "$IMPROVEMENTS" ] && CHANGELOG="${CHANGELOG}###  Improvements\n${IMPROVEMENTS}\n"
        [ ! -z "$OTHER" ] && CHANGELOG="${CHANGELOG}###  Other Changes\n${OTHER}\n"
        echo -e "$CHANGELOG" > changelog.md
        echo "Generated changelog:"
        cat changelog.md
        {
          echo 'changelog<<EOF'
          cat changelog.md
          echo EOF
        } >> $GITHUB_OUTPUT
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Check if artifacts exist (handle build skipping scenario)
      id: check-artifacts
      run: |
        if [ -d "artifacts" ] && [ "$(ls -A artifacts)" ]; then
          echo "artifacts_exist=true" >> $GITHUB_OUTPUT
          echo "Artifacts found - proceeding with release"
        else
          echo "artifacts_exist=false" >> $GITHUB_OUTPUT
          echo "No artifacts found - builds were skipped"
          echo "Will attempt to find and link to previous build with same commit"
          
          # Try to find a previous release with the same commit hash
          COMMIT_HASH="${{ github.sha }}"
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "Looking for existing artifacts with commit: $COMMIT_HASH"
        fi

    - name: Find and download previous artifacts if builds were skipped
      id: find-previous
      if: steps.check-artifacts.outputs.artifacts_exist == 'false'
      run: |
        echo "Searching for previous release with commit ${{ steps.check-artifacts.outputs.commit_hash }}"
        
        # Use GitHub API to find releases
        RELEASES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/releases?per_page=50")
        
        # Look for a release with matching commit (in tag or body)
        MATCHING_RELEASE=$(echo "$RELEASES" | jq -r '.[] | select(.body | contains("${{ steps.check-artifacts.outputs.commit_hash }}")) | .tag_name' | head -n1)
        
        if [ -n "$MATCHING_RELEASE" ] && [ "$MATCHING_RELEASE" != "null" ]; then
          echo "Found matching release: $MATCHING_RELEASE"
          echo "previous_release_tag=$MATCHING_RELEASE" >> $GITHUB_OUTPUT
          
          # Download assets from the matching release
          mkdir -p reused-artifacts
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$MATCHING_RELEASE")
          
          # Download all assets
          echo "$RELEASE_INFO" | jq -r '.assets[].browser_download_url' | while read -r url; do
            if [ -n "$url" ]; then
              filename=$(basename "$url")
              echo "Downloading: $filename"
              curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -o "reused-artifacts/$filename" "$url"
            fi
          done
          
          echo "reused_artifacts_available=true" >> $GITHUB_OUTPUT
          ls -la reused-artifacts/
        else
          echo "No matching release found with commit ${{ steps.check-artifacts.outputs.commit_hash }}"
          echo "reused_artifacts_available=false" >> $GITHUB_OUTPUT
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: List downloaded files for debugging
      if: steps.check-artifacts.outputs.artifacts_exist == 'true'
      run: ls -R artifacts
      
    - name: List reused artifacts for debugging
      if: steps.check-artifacts.outputs.artifacts_exist == 'false'
      run: |
        if [ -d "reused-artifacts" ]; then
          echo "Reused artifacts found:"
          ls -la reused-artifacts/
        else
          echo "No reused artifacts available"
        fi
    
    - name: Create Development Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.setup-version.outputs.version }}
        name: "${{ (github.ref_name == 'main' || github.ref_name == 'master') && ' Production Release' || ' Development Build' }} ${{ needs.setup-version.outputs.version }}"
        body: |
          ${{ (github.ref_name == 'main' || github.ref_name == 'master') && ' **Production Release** 

          This is an official production release of Artemis Desktop.

          ** Stable**: This release has been tested and is recommended for general use.' || ' **Development Build** 
          
          This is an automated development build from the `develop` branch.
          
          ** Warning**: Development builds are unstable and intended for testing purposes only. Use at your own risk!' }}
          
          ---
          
          ${{ steps.changelog.outputs.changelog }}
          
          ---
          
          ##  Build Information
          - **Version**: `${{ needs.setup-version.outputs.version }}`
          - **Numeric Version**: `${{ needs.setup-version.outputs.numeric_version }}`
          - **Branch**: `${{ github.ref_name }}`
          - **Commit**: `${{ github.sha }}`
          - **Build**: #${{ github.run_number }}
          
          ##  Installation
          ${{ (steps.check-artifacts.outputs.artifacts_exist == 'true' || steps.find-previous.outputs.reused_artifacts_available == 'true') && '1. Download the appropriate file for your platform
          2. Extract the archive (if applicable)
          3. Run the executable (may require additional setup on some platforms)' || 'No installation files are available for this release. Please check recent releases or feature branches for builds.' }}
          
          ##